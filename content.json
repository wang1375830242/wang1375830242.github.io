{"meta":{"title":"樱花🌸","subtitle":null,"description":"樱花🌸，小坏孩的小博客","author":"小坏孩","url":"https://www.sakura521.cn","root":"/"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2022-08-04T06:52:27.913Z","comments":false,"path":"about/index.html","permalink":"https://www.sakura521.cn/about/index.html","excerpt":"","text":"[さくら荘の小坏孩] 与&nbsp; 小坏孩&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2022-08-04T06:52:27.914Z","comments":false,"path":"bangumi/index.html","permalink":"https://www.sakura521.cn/bangumi/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2022-08-04T06:52:27.915Z","comments":false,"path":"client/index.html","permalink":"https://www.sakura521.cn/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2022-08-04T06:52:27.917Z","comments":false,"path":"donate/index.html","permalink":"https://www.sakura521.cn/donate/index.html","excerpt":"","text":""},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2022-08-04T06:52:27.918Z","comments":true,"path":"links/index.html","permalink":"https://www.sakura521.cn/links/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2022-08-04T06:52:27.918Z","comments":false,"path":"lab/index.html","permalink":"https://www.sakura521.cn/lab/index.html","excerpt":"","text":"sakura主题balabala"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2022-08-04T06:52:27.916Z","comments":true,"path":"comment/index.html","permalink":"https://www.sakura521.cn/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2022-08-04T06:52:27.919Z","comments":false,"path":"music/index.html","permalink":"https://www.sakura521.cn/music/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2022-08-04T06:52:27.923Z","comments":true,"path":"rss/index.html","permalink":"https://www.sakura521.cn/rss/index.html","excerpt":"","text":""},{"title":"[object Object]","date":"2022-08-04T06:52:27.923Z","updated":"2022-08-04T06:52:27.923Z","comments":true,"path":"scaffolds/draft.html","permalink":"https://www.sakura521.cn/scaffolds/draft.html","excerpt":"","text":""},{"title":"[object Object]","date":"2022-08-04T06:52:27.924Z","updated":"2022-08-04T06:52:27.924Z","comments":false,"path":"scaffolds/page.html","permalink":"https://www.sakura521.cn/scaffolds/page.html","excerpt":"","text":""},{"title":"[object Object]","date":"2022-08-04T06:52:27.924Z","updated":"2022-08-04T06:52:27.924Z","comments":true,"path":"scaffolds/post.html","permalink":"https://www.sakura521.cn/scaffolds/post.html","excerpt":"","text":"","author":"hojun"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2022-08-04T06:52:27.925Z","comments":true,"path":"tags/index.html","permalink":"https://www.sakura521.cn/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2022-08-04T06:52:27.927Z","comments":false,"path":"video/index.html","permalink":"https://www.sakura521.cn/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2022-08-04T06:52:27.926Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://www.sakura521.cn/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro"}],"posts":[{"title":"使用 Docker 部署一个 Spring Boot 项目","slug":"使用Docker部署一个SpringBoot项目","date":"2020-07-08T13:45:20.000Z","updated":"2022-08-04T06:52:27.908Z","comments":true,"path":"technology/docker.html","link":"","permalink":"https://www.sakura521.cn/technology/docker.html","excerpt":"","text":"Docker 维基百科Docker 是一个开放源代码软件，是一个开放平台，用于开发应用、交付（shipping）应用、运行应用。 Docker允许用户将基础设施（Infrastructure）中的应用单独分割出来，形成更小的颗粒（容器），从而提高交付软件的速度。[1] Docker容器 与虚拟机类似，但原理上，容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件，因此容器更具有便携性、高效地利用服务器。 容器更多的用于表示 软件的一个标准化单元。由于容器的标准化，因此它可以无视基础设施（Infrastructure）的差异，部署到任何一个地方。另外，Docker也为容器提供更强的业界的隔离兼容。[2] Docker 利用Linux核心中的资源分离机制，例如cgroups，以及Linux核心名字空间（namespaces），来创建独立的容器（containers）。这可以在单一Linux实体下运作，避免引导一个虚拟机造成的额外负担[3]。Linux核心对名字空间的支持完全隔离了工作环境中应用程序的视野，包括行程树、网络、用户ID与挂载文件系统，而核心的cgroup提供资源隔离，包括CPU、存储器、block I&#x2F;O与网络。从0.9版本起，Dockers在使用抽象虚拟是经由libvirt的LXC与systemd - nspawn提供界面的基础上，开始包括libcontainer库做为以自己的方式开始直接使用由Linux核心提供的虚拟化的设施， 依据行业分析公司“451研究”：“Dockers是有能力打包应用程序及其虚拟容器，可以在任何Linux服务器上运行的依赖性工具，这有助于实现灵活性和便携性，应用程序在任何地方都可以运行，无论是公用云、私有云、单机等。” [4]。 Docker 安装安装方式有很多种，我是第一次接触，所以我安装的windows版本的 我电脑是Win10 家庭版，所以不能直接安装docker官方的docker-ce-desktop-windows，网上看到有强制开启Hyper-V的，因为改注册表犹豫了下，查了查如果强制开启话的 VMware 可能就无法使用了，而且貌似没有看到关闭的方法。 所以我使用的安装 docker-toolbox 这个保守的办法。 安装方法我就我说了，直接百度就有很多种。 安装完需要配置和修改（有些教程没有注意） 部署 Spring Boot项目创建一个spring boot 项目我的pom.xml我看的那个教程在这里面添加了一些东西，但是很多教程在pom.xml并没有做修改。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;hello_docker&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;hello_docker&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;docker.imager.prefix&gt;springboot&lt;/docker.imager.prefix&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;$&#123;docker.imager.prefix&#125;/$&#123;project.artifactId&#125;&lt;/imageName&gt; &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 然后创建个显示测试效果的例如： /** * @Author sakura * @Date 2020-07-08 17:13 */ @RestController public class helloDockerController &#123; @GetMapping(&quot;/hello&quot;) public String helloDocker() &#123; return &quot;hello docker !!!&quot;; &#125; &#125; 运行访问 127.0.0.1:8080&#x2F;hello 显示 hello docker !!! 打包 打包完后的文件在target中 创建 Dockerfile在main目录下创建docker文件夹，在此文件夹下创建Dockerfile并且把刚才打包好的文件复制进来 目录截图： 编辑DockerfileFROM java:8 VOLUME /tmp ADD hello_docker-0.0.1-SNAPSHOT.jar app.jar ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 附：【Dockerfile指令详解】 FROM：指定基础镜像，必须为第一个命令 MAINTAINER: 维护者信息 RUN：构建镜像时执行的命令 ADD：将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget COPY：功能类似ADD，但是是不会自动解压文件，也不能访问网络资源 CMD：构建容器后调用，也就是在容器启动时才进行调用。 ENTRYPOINT：配置容器，使其可执行化。配合CMD可省去&quot;application&quot;，只使用参数。 LABEL：用于为镜像添加元数据 ENV：设置环境变量 EXPOSE：指定于外界交互的端口 VOLUME：用于指定持久化目录 WORKDIR：工作目录，类似于cd命令 USER:指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。使用USER指定用户时，可以使用用户名、UID或GID，或是两者的组合。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户 ARG：用于指定传递给构建运行时的变量 ONBUILD：用于设置镜像触发器 ENTRYPOINT:配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。每个 Dockerfile 中只能有一个 ENTRYPOINT ，当指定多个时，只有最后一个起效。 格式：ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] ENTRYPOINT command param1 param2 （shell中执行） 使用Docker使用Dockerfile创建镜像mvn package docker:build 显示： ... [INFO] Building image springboot/hello_docker Step 1/4 : FROM java:8 ---&gt; d23bdf5b1b1b Step 2/4 : VOLUME /tmp ---&gt; Using cache ---&gt; 8facd0d5489f Step 3/4 : ADD hello_docker-0.0.1-SNAPSHOT.jar app.jar ---&gt; Using cache ---&gt; 8f39142f4505 Step 4/4 : ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] ---&gt; Using cache ---&gt; 3ee7df4eff03 ProgressMessage&#123;id=null, status=null, stream=null, error=null, progress=null, progressDetail=null&#125; Successfully built 3ee7df4eff03 Successfully tagged springboot/hello_docker:latest [INFO] Built springboot/hello_docker [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 12.577 s [INFO] Finished at: 2020-07-09T10:06:31+08:00 [INFO] ------------------------------------------------------------------------ 使用 docker images 命令查看构建好的镜像H:\\桌面文件\\学習\\练\\hello_docker&gt;docker images REPOSITORY TAG IMAGE ID CREATED SIZE springboot/hello_docker latest 3ee7df4eff03 16 hours ago 660MB &lt;none&gt; &lt;none&gt; 57b58e5de4e5 17 hours ago 105MB openjdk 8-jdk-alpine a3562aa0b991 14 months ago 105MB java 8 d23bdf5b1b1b 3 years ago 643MB 这个springboot&#x2F;hello_docker就是构建好的镜像，然后运行镜像docker run -p 8088:8080 -t springboot/hello_docker -p 8088:8080 ：主机的端口和docker容器中的端口做映射 启动命令详情官网：https://docs.docker.com/engine/reference/commandline/run/ 启动后用docker ps 查看正在运行的镜像H:\\桌面文件\\学習\\练\\hello_docker&gt;docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 23617af8aed8 springboot/hello_docker &quot;java -jar /app.jar&quot; 6 seconds ago Up 7 seconds 0.0.0.0:8088-&gt;8080/tcp zen_feynman 访问浏览器 192.168.99.100:8088&#x2F;hellohello docker !!! 192.168.99.100 这启动docker服务的地方看，每个人可能不一样 第一次接触暂时先写到这","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"java","slug":"java","permalink":"https://www.sakura521.cn/tags/java/"}],"author":"小坏孩"},{"title":"java 散知识 学习小记","slug":"java-散知识-学习小记","date":"2020-06-16T08:31:23.000Z","updated":"2022-08-04T06:52:27.905Z","comments":true,"path":"technology/javastudy20200616.html","link":"","permalink":"https://www.sakura521.cn/technology/javastudy20200616.html","excerpt":"","text":"java代码 public static void main(String[] args) &#123; // int Integer区别 Integer a = new Integer(3); Integer b = 3; int c = 3; System.out.println(a.equals(b)); System.out.println(a == b); System.out.println(a == c); System.out.println(b == c); System.out.println(&quot;----------------------------------&quot;); // 自动装箱 拆箱 相关关系 Integer f1 = 100, f2 = 100, f3 = 155, f4 = 155; /* 简单的说，如果整型字面量的值在-128到127之间， 那么不会new新的Integer对象， 而是直接引用常量池中的Integer对象， 所以f1==f2的结果是true，而f3==f4的结果是false。*/ System.out.println(f1 == f2); // true System.out.println(f3 == f4); // false System.out.println(&quot;----------------------------------&quot;); // java虚拟机会自动调用System类 // sun.misc.Version.init(); // sun.misc.Version类会在JDK类库的初始化过程中被加载并初始化。 String s1 = new StringBuilder(&quot;go&quot;).append(&quot;od&quot;).toString(); System.out.println(s1.intern() == s1); String s2 = new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString(); System.out.println(s2.intern() == s2); String s3 = new StringBuilder(&quot;Java(TM) SE &quot;).append(&quot;Runtime Environment&quot;).toString(); System.out.println(s3.intern() == s3); System.out.println(&quot;----------------------------------&quot;); // 四舍五入 long round = Math.round(11.5); long round2 = Math.round(-11.5); System.out.println(&quot;round = &quot; + round); System.out.println(&quot;round2 = &quot; + round2); // i = 3 * 8（2的3次方） int i = 3 &lt;&lt; 3; System.out.println(&quot;i = &quot; + i); System.out.println(&quot;----------------------------------&quot;); // 数组没有length()方法，String有length()方法 String length = &quot;length&quot;; System.out.println(length.length()); System.out.println(&quot;----------------------------------&quot;); // String StringBuilder StringBuffer 的区别 String sr1 = &quot;Programming&quot;; String sr2 = new String(&quot;Programming&quot;); String sr3 = &quot;Program&quot;; String sr4 = &quot;ming&quot;; String sr5 = &quot;Program&quot; + &quot;ming&quot;; String sr6 = sr3 + sr4; System.out.println(sr1 == sr2); System.out.println(sr1 == sr5); System.out.println(sr1 == sr6); System.out.println(sr1 == sr6.intern()); System.out.println(sr2 == sr2.intern()); System.out.println(&quot;----------------------------------&quot;); // 交换x y 数值 int x = 1; int y = 2; x = x ^ y; // 此时x的值为x ^ y用来暂存x和y的值 y = x ^ y; // 即 y = (x ^ y) ^y = x ^ (y ^ y) = x ^ 0 = x; 此时y的值为1; x = x ^ y; // 即 x = (x ^ y) ^ x = y ^ (x ^ x) = y ^ 0 = y; 此时x的值为2; System.out.println(&quot;x = &quot; + x); System.out.println(&quot;y = &quot; + y); // 在数组中找出只出现一次的数字 int[] nums = new int[5]; nums[0] = 1; nums[1] = 1; nums[2] = 3; nums[3] = 2; nums[4] = 2; int iii = 0; for (int num : nums) &#123; iii ^= num; &#125; System.out.println(&quot;只出现一次的数字为&quot; + iii); System.out.println(&quot;----------------------------------&quot;); // char类型可以存储一个中文汉字， // 因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法）， // 一个char类型占2个字节（16比特），所以放一个中文是没问题的。 // char型变量中能存储一个中文汉字（这个汉字 𪚥（zhé 字符串为\\uD869\\uDEA5） 不行，那个biang打不出来所以试不成 ） // char cr = &#39;𪚥&#39;; char cr = &#39;齉&#39;; // nàng System.out.println(&quot;char类型包含一个汉字 = &quot; + cr); &#125; 运行结果true false true true ---------------------------------- true false ---------------------------------- true false false ---------------------------------- round = 12 round2 = -11 i = 24 ---------------------------------- 6 ---------------------------------- false true false true false ---------------------------------- x = 2 y = 1 只出现一次的数字为3 ---------------------------------- char类型包含一个汉字 = 齉 Process finished with exit code 0 代码2public class A &#123; static &#123; System.out.print(&quot;1&quot;); &#125; public A() &#123; System.out.print(&quot;2&quot;); &#125; &#125; public class B extends A&#123; static &#123; System.out.print(&quot;a&quot;); &#125; public B() &#123; System.out.print(&quot;b&quot;); &#125; &#125; public class AB &#123; public static void main(String[] args) &#123; A ab = new B(); ab = new B(); &#125; &#125; 运行结果1a2b2b","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"java","slug":"java","permalink":"https://www.sakura521.cn/tags/java/"}],"author":"小坏孩"},{"title":"Spring Boot RabbitMQ 小练习","slug":"Spring-Boot-RabbitMQ-小练习","date":"2020-06-14T07:46:04.000Z","updated":"2022-08-04T06:52:27.903Z","comments":true,"path":"technology/rabbitMQ.html","link":"","permalink":"https://www.sakura521.cn/technology/rabbitMQ.html","excerpt":"","text":"RabbitMQ官网：https://www.rabbitmq.com/ RabbitMQ是部署最广泛的开源消息代理。 RabbitMQ拥有成千上万的用户，是最受欢迎的开源消息代理之一。从T-Mobile 到Runtastic，RabbitMQ在全球范围内的小型初创企业和大型企业中都得到使用。 RabbitMQ轻巧，易于在内部和云中部署。它支持多种消息传递协议。RabbitMQ可以部署在分布式和联合配置中，以满足大规模，高可用性的要求。 RabbitMQ可在许多操作系统和云环境上运行，并为大多数流行语言提供了广泛的开发人员工具。 Spring Boot 整合 RabbitMQ配置添加依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 配置spring: rabbitmq: host: 127.0.0.1 username: guest password: guest 一对一：一个发送者一个接收者队列配置import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabvitConfig &#123; @Bean public Queue queue() &#123; return new Queue(&quot;hello&quot;); &#125; &#125; 发送import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import java.time.LocalDateTime; @Component public class HelloSender &#123; @Autowired private AmqpTemplate amqpTemplate; public void send() &#123; String context = &quot;hello---&quot; + LocalDateTime.now(); System.out.println(&quot;context = &quot; + context); amqpTemplate.convertAndSend(&quot;hello&quot;, context); &#125; &#125; 接收import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;hello&quot;) public class HelloReceiver &#123; // 消息处理器 @RabbitHandler public void process(String message) &#123; System.out.println(&quot;message = &quot; + message); &#125; &#125; 测试import cn.sakura521.redis_demo.demo.HelloSender; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class RedisDemoApplicationTests &#123; @Autowired private HelloSender helloSender; @Test void contextLoads() &#123; helloSender.send(); &#125; &#125; 测试结果context = hello---2020-06-14T15:41:22.320 message = hello---2020-06-14T15:41:22.320 一对多：发送一个发送者多个接收者添加队列import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabvitConfig &#123; @Bean public Queue queue() &#123; return new Queue(&quot;hello&quot;); &#125; @Bean public Queue queue2() &#123; return new Queue(&quot;hello2&quot;); &#125; &#125; 发送import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import java.time.LocalDateTime; @Component public class HelloSender &#123; @Autowired private AmqpTemplate amqpTemplate; public void send2(int i) &#123; String context = i + &quot;&quot;; System.out.println(context + &quot;----send&quot;); amqpTemplate.convertAndSend(&quot;hello2&quot;, context); &#125; &#125; 接收两个接收者 接收者1import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;hello2&quot;) public class HelloReceiver1 &#123; @RabbitHandler public void process(String message)&#123; System.out.println(&quot;HelloReceiver1 = &quot; + message); &#125; &#125; 接收者2import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;hello2&quot;) public class HelloReceiver2 &#123; @RabbitHandler public void process(String message)&#123; System.out.println(&quot;HelloReceiver2 = &quot; + message); &#125; &#125; 测试import cn.sakura521.redis_demo.demo.HelloSender; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class RedisDemoApplicationTests &#123; @Autowired private HelloSender helloSender; @Test void mangReceiver() &#123; for (int i = 0; i &lt; 25; i++) &#123; helloSender.send2(i); &#125; &#125; &#125; 测试结果多次测试每次测试显示均不一样。 0----send 1----send 2----send 3----send 4----send 5----send 6----send 7----send 8----send 9----send 10----send 11----send 12----send 13----send 14----send 15----send 16----send 17----send 18----send 19----send 20----send 21----send 22----send 23----send 24----send HelloReceiver1 = 0 HelloReceiver1 = 2 HelloReceiver1 = 4 HelloReceiver1 = 6 HelloReceiver2 = 1 HelloReceiver1 = 8 HelloReceiver2 = 3 HelloReceiver2 = 5 HelloReceiver2 = 7 HelloReceiver1 = 10 HelloReceiver1 = 12 HelloReceiver1 = 14 HelloReceiver1 = 16 多对多：多个发送者对多个接收者更改上一个测试用例 测试import cn.sakura521.redis_demo.demo.HelloSender; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class RedisDemoApplicationTests &#123; @Autowired private HelloSender helloSender; @Test void mangReceiver() &#123; for (int i = 0; i &lt; 25; i++) &#123; helloSender.send(); helloSender.send2(i); &#125; &#125; &#125; 测试结果context = hello---2020-06-14T17:16:44.640 0----send context = hello---2020-06-14T17:16:44.647 1----send context = hello---2020-06-14T17:16:44.649 2----send context = hello---2020-06-14T17:16:44.649 3----send context = hello---2020-06-14T17:16:44.649 4----send context = hello---2020-06-14T17:16:44.649 5----send context = hello---2020-06-14T17:16:44.650 6----send context = hello---2020-06-14T17:16:44.656 7----send context = hello---2020-06-14T17:16:44.657 8----send context = hello---2020-06-14T17:16:44.657 9----send context = hello---2020-06-14T17:16:44.658 10----send context = hello---2020-06-14T17:16:44.658 11----send context = hello---2020-06-14T17:16:44.659 12----send context = hello---2020-06-14T17:16:44.660 13----send context = hello---2020-06-14T17:16:44.660 14----send context = hello---2020-06-14T17:16:44.660 15----send context = hello---2020-06-14T17:16:44.661 16----send context = hello---2020-06-14T17:16:44.663 17----send context = hello---2020-06-14T17:16:44.663 18----send context = hello---2020-06-14T17:16:44.668 19----send context = hello---2020-06-14T17:16:44.669 20----send context = hello---2020-06-14T17:16:44.670 21----send context = hello---2020-06-14T17:16:44.671 22----send context = hello---2020-06-14T17:16:44.671 23----send context = hello---2020-06-14T17:16:44.672 24----send HelloReceiver2 = 1 HelloReceiver = hello---2020-06-14T17:16:44.640 HelloReceiver1 = 0 HelloReceiver2 = 3 HelloReceiver = hello---2020-06-14T17:16:44.647 HelloReceiver2 = 5 HelloReceiver1 = 2 HelloReceiver = hello---2020-06-14T17:16:44.649 HelloReceiver2 = 7 HelloReceiver1 = 4 HelloReceiver2 = 9 HelloReceiver = hello---2020-06-14T17:16:44.649 HelloReceiver1 = 6 HelloReceiver2 = 11 HelloReceiver1 = 8 HelloReceiver2 = 13 HelloReceiver1 = 10 HelloReceiver = hello---2020-06-14T17:16:44.649 HelloReceiver = hello---2020-06-14T17:16:44.649 HelloReceiver2 = 15 HelloReceiver = hello---2020-06-14T17:16:44.650 HelloReceiver = hello---2020-06-14T17:16:44.656 HelloReceiver1 = 12 HelloReceiver = hello---2020-06-14T17:16:44.657 HelloReceiver1 = 14 HelloReceiver = hello---2020-06-14T17:16:44.657 HelloReceiver = hello---2020-06-14T17:16:44.658 HelloReceiver = hello---2020-06-14T17:16:44.658 HelloReceiver = hello---2020-06-14T17:16:44.659 HelloReceiver = hello---2020-06-14T17:16:44.660 HelloReceiver = hello---2020-06-14T17:16:44.660 HelloReceiver = hello---2020-06-14T17:16:44.660 HelloReceiver = hello---2020-06-14T17:16:44.661 HelloReceiver = hello---2020-06-14T17:16:44.663 HelloReceiver1 = 16 HelloReceiver2 = 17 HelloReceiver1 = 18 HelloReceiver1 = 20 HelloReceiver1 = 22 HelloReceiver2 = 19 HelloReceiver = hello---2020-06-14T17:16:44.663 HelloReceiver1 = 24 HelloReceiver2 = 21 HelloReceiver = hello---2020-06-14T17:16:44.668 HelloReceiver2 = 23 HelloReceiver = hello---2020-06-14T17:16:44.669 HelloReceiver = hello---2020-06-14T17:16:44.670 HelloReceiver = hello---2020-06-14T17:16:44.671 HelloReceiver = hello---2020-06-14T17:16:44.671 HelloReceiver = hello---2020-06-14T17:16:44.672 发送对象创建对象首先创建对象User,并实现Serializable接口 import java.io.Serializable; public class User implements Serializable &#123; private String username; private String password; public User(String username, String password) &#123; this.username = username; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;username=&#39;&quot; + username + &#39;\\&#39;&#39; + &quot;, password=&#39;&quot; + password + &#39;\\&#39;&#39; + &#39;&#125;&#39;; &#125; &#125; 创建队列import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabvitConfig &#123; @Bean public Queue queue3() &#123; return new Queue(&quot;object_queue&quot;); &#125; &#125; 发送import cn.sakura521.redis_demo.pojo.User; import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class ObjectSender &#123; @Autowired private AmqpTemplate amqpTemplate; public void sendUser(User user) &#123; System.out.println(&quot;sendUser = &quot; + user); amqpTemplate.convertAndSend(&quot;object_queue&quot;, user); &#125; &#125; 接收import cn.sakura521.redis_demo.pojo.User; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;object_queue&quot;) public class ObjectReceiver &#123; @RabbitHandler public void objectReceiver(User user) &#123; System.out.println(&quot;objectReceiver = &quot; + user); &#125; &#125; 测试import cn.sakura521.redis_demo.demo.HelloSender; import cn.sakura521.redis_demo.demo.ObjectSender; import cn.sakura521.redis_demo.pojo.User; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class RedisDemoApplicationTests &#123; @Autowired private ObjectSender objectSender; @Test void sendUser() &#123; User user = new User(&quot;小坏孩&quot;, &quot;123456&quot;); objectSender.sendUser(user); &#125; &#125; 测试结果sendUser = User&#123;username=&#39;小坏孩&#39;, password=&#39;123456&#39;&#125; objectReceiver = User&#123;username=&#39;小坏孩&#39;, password=&#39;123456&#39;&#125; Topic Exchangetopic 是RabbitMQ中最灵活的一种方式，可以根据routing_key自由的绑定不同的队列 topic规则配置import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.Queue; import org.springframework.amqp.core.TopicExchange; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class TopicRabbitConfig &#123; final static String message = &quot;topic.message&quot;; final static String messages = &quot;topic.messages&quot;; @Bean public Queue queueMsg() &#123; return new Queue(TopicRabbitConfig.message); &#125; @Bean public Queue queueMsgs() &#123; return new Queue(TopicRabbitConfig.messages); &#125; // 配置 TopicExchange,指定名称为 topicExchange @Bean public TopicExchange exchange() &#123; return new TopicExchange(&quot;topicExchange&quot;); &#125; // 给队列绑定exchange和routing_key @Bean public Binding bindingExchangeMessage(Queue queueMsg, TopicExchange exchange) &#123; return BindingBuilder.bind(queueMsg).to(exchange).with(&quot;topic.message&quot;); &#125; @Bean public Binding bindingExchangeMessages(Queue queueMsgs, TopicExchange exchange) &#123; return BindingBuilder.bind(queueMsgs).to(exchange).with(&quot;topic.#&quot;); &#125; &#125; 发送消息发送者:都是用topicExchange,并且绑定到不同的 routing_key import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class TopicSender &#123; @Autowired private AmqpTemplate amqpTemplate; public void send1() &#123; String context = &quot;消息1&quot;; System.out.println(&quot;Sender1 = &quot; + context); amqpTemplate.convertAndSend(&quot;topicExchange&quot;, &quot;topic.message&quot;, context); &#125; public void send2() &#123; String context = &quot;消息2&quot;; System.out.println(&quot;Sender2 = &quot; + context); amqpTemplate.convertAndSend(&quot;topicExchange&quot;, &quot;topic.messages&quot;, context); &#125; &#125; 接收接收1import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;topic.message&quot;) public class TopicReceiver1 &#123; @RabbitHandler public void process(String message)&#123; System.out.println(&quot;topic.message = &quot; + message); &#125; &#125; 接收2import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;topic.messages&quot;) public class TopicReceiver2 &#123; @RabbitHandler public void process(String message)&#123; System.out.println(&quot;topic.messages = &quot; + message); &#125; &#125; 测试package cn.sakura521.redis_demo; import cn.sakura521.redis_demo.demo.HelloSender; import cn.sakura521.redis_demo.demo.ObjectSender; import cn.sakura521.redis_demo.demo.TopicSender; import cn.sakura521.redis_demo.pojo.User; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class RedisDemoApplicationTests &#123; @Autowired private TopicSender topicSender; @Test void topicSender() &#123; topicSender.send1(); System.out.println(&quot;---------------------------------------&quot;); topicSender.send2(); &#125; &#125; 测试结果Sender1 = 消息1 --------------------------------------- Sender2 = 消息2 topic.messages = 消息1 topic.message = 消息1 topic.messages = 消息2 Fanout ExchangeFanout 就是我们熟悉的广播模式或者订阅模式，给Fanout交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。 配置import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.FanoutExchange; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class FanQutRabbitMq &#123; @Bean public Queue AMessage() &#123; return new Queue(&quot;fanout.A&quot;); &#125; @Bean public Queue BMessage() &#123; return new Queue(&quot;fanout.B&quot;); &#125; @Bean public Queue CMessage() &#123; return new Queue(&quot;fanout.C&quot;); &#125; @Bean public FanoutExchange fanoutExchange() &#123; return new FanoutExchange(&quot;fanoutExchange&quot;); &#125; //分别给三个队列指定exchange,这里使用了A、B、C三个队列绑定到Fanout交换机上面，发送端的routing_key写任何字符都会被忽略： @Bean public Binding bindingExchangeA(Queue AMessage, FanoutExchange fanoutExchange) &#123; return BindingBuilder.bind(AMessage).to(fanoutExchange); &#125; @Bean public Binding bindingExchangeB(Queue BMessage, FanoutExchange fanoutExchange) &#123; return BindingBuilder.bind(BMessage).to(fanoutExchange); &#125; @Bean public Binding bindingExchangeC(Queue CMessage, FanoutExchange fanoutExchange) &#123; return BindingBuilder.bind(CMessage).to(fanoutExchange); &#125; &#125; 发送import org.springframework.amqp.core.AmqpTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class FanoutSender &#123; @Autowired private AmqpTemplate amqpTemplate; public void send() &#123; String context = &quot;hi,fanout.msg&quot;; System.out.println(&quot;Sender = &quot; + context); //这里使用了A、B、C三个队列绑定到Fanout交换机上面，发送端的routing_key写任何字符都会被忽略： amqpTemplate.convertAndSend(&quot;fanoutExchange&quot;, &quot;&quot;, context); &#125; &#125; 接收接收者Aimport org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;fanout.A&quot;) public class FanoutReceiverA &#123; @RabbitHandler public void process(String message)&#123; System.out.println(&quot;Receiver form fanout.A: &quot; + message); &#125; &#125; 接收者Bimport org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;fanout.B&quot;) public class FanoutReceiverB &#123; @RabbitHandler public void process(String message)&#123; System.out.println(&quot;Receiver form fanout.B: &quot; + message); &#125; &#125; 接收者Cimport org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Component @RabbitListener(queues = &quot;fanout.C&quot;) public class FanoutReceiverC &#123; @RabbitHandler public void process(String message)&#123; System.out.println(&quot;Receiver form fanout.C: &quot; + message); &#125; &#125; 测试package cn.sakura521.redis_demo; import cn.sakura521.redis_demo.demo.FanoutSender; import cn.sakura521.redis_demo.demo.HelloSender; import cn.sakura521.redis_demo.demo.ObjectSender; import cn.sakura521.redis_demo.demo.TopicSender; import cn.sakura521.redis_demo.pojo.User; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class RedisDemoApplicationTests &#123; @Autowired private FanoutSender fanoutSender; @Test void fanoutSender()&#123; fanoutSender.send(); &#125; &#125; 测试结果Sender = hi,fanout.msg Receiver form fanout.B: hi,fanout.msg Receiver form fanout.C: hi,fanout.msg Receiver form fanout.A: hi,fanout.msg 最终全部测试用例import cn.sakura521.redis_demo.demo.FanoutSender; import cn.sakura521.redis_demo.demo.HelloSender; import cn.sakura521.redis_demo.demo.ObjectSender; import cn.sakura521.redis_demo.demo.TopicSender; import cn.sakura521.redis_demo.pojo.User; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class RedisDemoApplicationTests &#123; @Autowired private HelloSender helloSender; @Autowired private ObjectSender objectSender; @Autowired private TopicSender topicSender; @Autowired private FanoutSender fanoutSender; @Test void contextLoads() &#123; helloSender.send(); &#125; @Test void mangReceiver() &#123; for (int i = 0; i &lt; 25; i++) &#123; helloSender.send(); helloSender.send2(i); &#125; &#125; @Test void sendUser() &#123; User user = new User(&quot;小坏孩&quot;, &quot;123456&quot;); objectSender.sendUser(user); &#125; @Test void topicSender() &#123; topicSender.send1(); System.out.println(&quot;---------------------------------------&quot;); topicSender.send2(); &#125; @Test void fanoutSender()&#123; fanoutSender.send(); &#125; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"java","slug":"java","permalink":"https://www.sakura521.cn/tags/java/"}],"author":"小坏孩"},{"title":"Java Steam流 学习小笔记","slug":"Java-Steam流-学习小笔记","date":"2020-06-04T08:49:20.000Z","updated":"2022-08-04T06:52:27.898Z","comments":true,"path":"technology/steam.html","link":"","permalink":"https://www.sakura521.cn/technology/steam.html","excerpt":"","text":"Java8 StreamJava 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。 Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。 Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。 元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。 +--------------------+ +------+ +------+ +---+ +-------+ | stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect| +--------------------+ +------+ +------+ +---+ +-------+ 学习代码记录List&lt;Long&gt; nums = Arrays.asList(3L, 3L, 39L, 32L, 123L, 534L, 46542L, 3211L); nums.stream() .map(integer -&gt; integer * integer + &quot; &quot;) .distinct() .collect(Collectors.toList()) .forEach(System.out::print); System.out.println(); System.out.println(&quot;----------------------------------------------&quot;); long count = nums.stream().filter(i -&gt; i.equals(3L)).count(); System.out.println(&quot;包含3L的有 = &quot; + count+&quot;个&quot;); System.out.println(&quot;----------------------------------------------&quot;); Random random = new Random(); System.out.println(&quot;随机数排序前&quot;); random.ints().limit(10).forEach(System.out::println); System.out.println(&quot;----------------------------------------------&quot;); System.out.println(&quot;随机数排序后&quot;); random.ints().limit(10).sorted().forEach(System.out::println); System.out.println(&quot;----------------------------------------------&quot;); List&lt;String&gt; strings = Arrays.asList(&quot;acas&quot;, &quot;&quot;, &quot;sda&quot;, &quot;sdadsaddsad&quot;, &quot;dwadas&quot;); long count1 = strings.parallelStream() .filter(s -&gt; s.isEmpty()).count(); System.out.println(&quot;在&quot;+strings+&quot;中包含空字符串有&quot; + count1 + &quot;个&quot;); System.out.println(&quot;----------------------------------------------&quot;); List&lt;String&gt; collect = strings.stream() .filter(s -&gt; !s.isEmpty()) .collect(Collectors.toList()); System.out.println(&quot;去除空后的筛选列表&quot;+collect); System.out.println(&quot;----------------------------------------------&quot;); String collect1 = strings.stream() .filter(s -&gt; !s.isEmpty()) .collect(Collectors.joining(&quot;,&quot;)); System.out.println(&quot;将&quot;+strings+&quot;组合成一个string后：&quot; + collect1); System.out.println(&quot;----------------------------------------------&quot;); List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 4, 5, 6, 11, 111, 22, 12); IntSummaryStatistics intSummaryStatistics = integers.stream() .mapToInt((x) -&gt; x).summaryStatistics(); System.out.println(&quot;最大值:&quot;+intSummaryStatistics.getMax()); System.out.println(&quot;最小值:&quot;+intSummaryStatistics.getMin()); System.out.println(&quot;所有数之和:&quot;+intSummaryStatistics.getSum()); System.out.println(&quot;平均数:&quot;+intSummaryStatistics.getAverage()); 打印结果9 1521 1024 15129 285156 2166157764 10310521 ---------------------------------------------- 包含3L的有 = 2个 ---------------------------------------------- 随机数排序前 1399523865 374116917 -1454199312 1925671743 580107117 -2137427526 237695867 -55497742 -1502376427 1398197257 ---------------------------------------------- 随机数排序后 -2130838075 -1574466058 -1469617767 -534793213 -158077868 -143294047 234751172 1147396663 1216434490 2103427929 ---------------------------------------------- 在[acas, , sda, sdadsaddsad, dwadas]中包含空字符串有1个 ---------------------------------------------- 去除空后的筛选列表[acas, sda, sdadsaddsad, dwadas] ---------------------------------------------- 将[acas, , sda, sdadsaddsad, dwadas]组合成一个string后：acas,sda,sdadsaddsad,dwadas ---------------------------------------------- 最大值:111 最小值:1 所有数之和:177 平均数:17.7 Process finished with exit code 0 6.5更新利用steam流对学生成绩进行分区 学生实体类import lombok.Data; @Data public class Student &#123; private String name; private int score; public Student(String name, int score) &#123; this.name = name; this.score = score; &#125; &#125; 处理public static void main(String[] args) &#123; List&lt;Student&gt; students = Arrays.asList( new Student(&quot;小红&quot;, 61), new Student(&quot;小绿&quot;, 51), new Student(&quot;小蓝&quot;, 60), new Student(&quot;小紫&quot;, 99), new Student(&quot;小粉&quot;, 100), new Student(&quot;小灰&quot;, 59) ); Map&lt;Boolean, List&lt;Student&gt;&gt; collect = students.stream() .collect(Collectors.partitioningBy(student -&gt; student.getScore() &gt; 59)); System.out.println(&quot;collect = &quot; + collect); System.out.println(&quot;及格的&quot;); System.out.println(collect.get(true)); System.out.println(&quot;不及格的&quot;); System.out.println(collect.get(false)); &#125; 打印结果collect = &#123;false=[Student(name=小绿, score=51), Student(name=小灰, score=59)], true=[Student(name=小红, score=61), Student(name=小蓝, score=60), Student(name=小紫, score=99), Student(name=小粉, score=100)]&#125; 及格的 [Student(name=小红, score=61), Student(name=小蓝, score=60), Student(name=小紫, score=99), Student(name=小粉, score=100)] 不及格的 [Student(name=小绿, score=51), Student(name=小灰, score=59)] Process finished with exit code 0","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"java","slug":"java","permalink":"https://www.sakura521.cn/tags/java/"}],"author":"小坏孩"},{"title":"使用OpenCV，Python和dlib进行眨眼检测","slug":"python-人眼识别-过程记录","date":"2020-04-15T02:24:20.000Z","updated":"2022-08-04T06:52:27.907Z","comments":true,"path":"technology/winkpython.html","link":"","permalink":"https://www.sakura521.cn/technology/winkpython.html","excerpt":"","text":"因为某些原因需要眨眼识别，看到这个第一个想到的就是python，但是没接触过这个语言，所以我先看的java的写法，发现挺少。于是开始下载python开始了下载各种软件的道路。。。 原网址虽然开始是在CSDN上花45积分下载的，但是发现这只是国外大佬写的。在这里给出国外大佬的原网址，就不给CSDN的了（明明人家免费，还在CSDN上卖45积分(小声BB)）。 https://www.pyimagesearch.com/2017/04/24/eye-blink-detection-opencv-python-dlib/ 问题原网址上相关配置已经很详细了。在这里我就写我自己碰到的坑。。。 主要是这些opencv ，numpy,以及dlib库，scipy库。 除了dlib库其他都是直接按照网上教程直接成功的。 在这就说一下这个安装吧，找了无数的方法。最后成功了，而且还是个超级简单的。。。 首先下载dlib-19.17.0-cp37-cp37m-win_amd64.whl我已经把这个文件放在了蓝奏云。 然后直接安装，在解压好的文件夹的cmd窗口输入下面的就可以了。 pip install 文件名.whl 这里就不配安装好的图了。 wink.py的代码贴出来(原文并没有中文，中文是我机翻的) # Command line parameters # python Wink.py --shape-predictor shape_predictor_68_face_landmarks.dat --video your videoname.mp4 # python Wink.py --shape-predictor shape_predictor_68_face_landmarks.dat # import the necessary packages from scipy.spatial import distance as dist from imutils.video import FileVideoStream from imutils.video import VideoStream from imutils import face_utils import numpy as np import argparse import imutils import time import dlib import cv2 import winsound def eye_aspect_ratio(eye): # compute the euclidean distances between the two sets of vertical eye landmarks (x, y)-coordinates # 计算两组垂直眼界标（x，y）坐标之间的欧几里得距离 A = dist.euclidean(eye[1], eye[5]) B = dist.euclidean(eye[2], eye[4]) # compute the euclidean distance between the horizontal eye landmark (x, y)-coordinates # 计算水平眼界标（x，y）坐标之间的欧几里得距离 C = dist.euclidean(eye[0], eye[3]) # compute the eye aspect ratio 计算眼睛长宽比 ear = (A + B) / (2.0 * C) # return the eye aspect ratio 返回眼睛长宽比 return ear # construct the argument parse and parse the arguments 构造参数解析并解析参数 ap = argparse.ArgumentParser() ap.add_argument(&quot;-p&quot;, &quot;--shape-predictor&quot;, required=True, help=&quot;path to facial landmark predictor&quot;) ap.add_argument(&quot;-v&quot;, &quot;--video&quot;, type=str, default=&quot;&quot;, help=&quot;path to input video file&quot;) args = vars(ap.parse_args()) # define two constants, one for the eye aspect ratio to indicate # blink and then a second constant for the number of consecutive frames the eye must be below the threshold # 定义两个常数，一个常数表示眼睛的纵横比以指示眨眼，然后定义第二个常数表示眼睛的连续帧数必须低于阈值 EYE_AR_THRESH = 0.25 EYE_AR_CONSEC_FRAMES = 2 # initialize the frame counters and the total number of blinks 初始化帧计数器和闪烁总数 COUNTER = 0 TOTAL = 0 # initialize dlib&#39;s face detector (HOG-based) and then create the facial landmark predictor # 初始化dlib的面部检测器（基于HOG），然后创建面部界标预测器 print(&quot;[INFO] loading facial landmark predictor...&quot;) detector = dlib.get_frontal_face_detector() predictor = dlib.shape_predictor(args[&quot;shape_predictor&quot;]) # grab the indexes of the facial landmarks for the left and right eye, respectively # 分别获取左眼和右眼的面部标志的索引 (lStart, lEnd) = face_utils.FACIAL_LANDMARKS_IDXS[&quot;left_eye&quot;] (rStart, rEnd) = face_utils.FACIAL_LANDMARKS_IDXS[&quot;right_eye&quot;] # start the video stream thread 启动视频流线程 print(&quot;[INFO] starting video stream thread...&quot;) # vs = FileVideoStream(args[&quot;video&quot;]).start() fileStream = True vs = VideoStream(src=0).start() fileStream = False time.sleep(1.0) # loop over frames from the video stream 循环播放视频流中的帧 while True: # if this is a file video stream, then we need to check if there any more frames left in the buffer to process # 如果这是文件视频流，那么我们需要检查缓冲区中是否还有剩余的帧要处理 if fileStream and not vs.more(): break # grab the frame from the threaded video file stream, resize it, and convert it # to grayscale channels) # 从线程视频文件流中抓取帧，调整其大小，然后将其转换为灰度通道） frame = vs.read() frame = imutils.resize(frame, width=450) gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # detect faces in the grayscale frame 在灰度框中检测人脸 rects = detector(gray, 0) # loop over the face detections 循环人脸检测 for rect in rects: # determine the facial landmarks for the face region, then convert # the facial landmark (x, y)-coordinates to a NumPy array # 确定面部区域的面部界标，然后将面部界标（x，y）坐标转换为NumPy数组 shape = predictor(gray, rect) shape = face_utils.shape_to_np(shape) # extract the left and right eye coordinates, then use the coordinates to compute the eye aspect ratio for both eyes # 提取左眼和右眼坐标，然后使用坐标计算两只眼睛的眼睛纵横比 leftEye = shape[lStart:lEnd] rightEye = shape[rStart:rEnd] leftEAR = eye_aspect_ratio(leftEye) rightEAR = eye_aspect_ratio(rightEye) # average the eye aspect ratio together for both eyes 将两只眼睛的眼睛纵横比平均在一起 ear = (leftEAR + rightEAR) / 2.0 # compute the convex hull for the left and right eye, then visualize each of the eyes # 计算左眼和右眼的凸包，然后可视化每只眼睛 leftEyeHull = cv2.convexHull(leftEye) rightEyeHull = cv2.convexHull(rightEye) cv2.drawContours(frame, [leftEyeHull], -1, (0, 255, 0), 1) cv2.drawContours(frame, [rightEyeHull], -1, (0, 255, 0), 1) # check to see if the eye aspect ratio is below the blink threshold, and if so, increment the blink frame counter # 检查眼睛宽高比是否低于眨眼阈值，如果是，则增加眨眼帧计数器 if ear &lt; EYE_AR_THRESH: COUNTER += 1 # otherwise, the eye aspect ratio is not below the blink threshold # 否则，眼睛纵横比不低于眨眼阈值 else: # if the eyes were closed for a sufficient number of then increment the total number of blinks # 如果闭上眼睛的次数足够多，则增加眨眼的总数 if COUNTER &gt;= EYE_AR_CONSEC_FRAMES: TOTAL += 1 # reset the eye frame counter 重置眼框计数器 COUNTER = 0 # draw the total number of blinks on the frame along with the computed eye aspect ratio for the frame # 绘制帧上眨眼的总数以及计算出的帧的眼睛纵横比 cv2.putText(frame, &quot;Blinks: &#123;&#125;&quot;.format(TOTAL), (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2) cv2.putText(frame, &quot;EAR: &#123;:.2f&#125;&quot;.format(ear), (300, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2) cv2.putText(frame, &quot;COUNTER: &#123;&#125;&quot;.format(COUNTER), (140, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2) # show the frame show the frame cv2.imshow(&quot;Frame&quot;, frame) key = cv2.waitKey(1) &amp; 0xFF # if the `q` key was pressed, break from the loop if key == ord(&quot;q&quot;): break # do a bit of cleanup cv2.destroyAllWindows() vs.stop() 使用python Wink.py --shape-predictor shape_predictor_68_face_landmarks.dat --video your videoname.mp4 python Wink.py --shape-predictor shape_predictor_68_face_landmarks.dat 效果图这个可以检测摄像头也可以检测视频里的，我都试过了可以，下面来个视频（周董的说好不哭的MV）的效果图（滑稽图）。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"}],"author":"小坏孩"},{"title":"谷歌访问助手破解版下载及安装","slug":"谷歌访问助手破解版下载及安装","date":"2020-04-12T08:58:47.000Z","updated":"2022-08-04T06:52:27.912Z","comments":true,"path":"technology/google.html","link":"","permalink":"https://www.sakura521.cn/technology/google.html","excerpt":"","text":"谷歌浏览器是一个非常方便，快速稳定的浏览器，而且拥有及其丰富的插件系统。 接下来我为大家推荐一个谷歌浏览器必备的一个插件。 谷歌访问助手 生活中很多问题在百度的上不到，我们就可以去时间上最大的搜索引擎https://www.google.com/ 但是以为一些原因我们无法直接访问到。 有了这个谷歌访问助手你就可以访问了，只不过直接百度的谷歌访问助手有广告，所以我把没有广告的破解版上传到蓝奏云（蓝奏云没有限速）了，在公众号回复 谷歌 即可得到链接。 下载链接： https://lanzous.com/ib775pa 安装在网址输入 chrome:&#x2F;&#x2F;extensions&#x2F; 或者点右上角的点 更多工具 扩展程序 先打开开发者模式，然后点击加载已解压的扩展程序，选择解压后的文件夹（注意文件夹） 选择文件夹后，你就可以看到下面这个，并且会弹出 谷歌访问助手已安装的页面，关掉就好 这样就可以了，下面是用谷歌搜索谷歌的效果展示。 原文链接【推荐】有了这个浏览器插件让你轻松上网 往期推荐【推荐】免费满速百度网盘下载","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"}],"author":"小坏孩"},{"title":"满速的百度网盘下载工具-亿寻","slug":"满速的百度网盘下载工具-亿寻","date":"2020-04-05T03:01:05.000Z","updated":"2022-08-04T06:52:27.911Z","comments":true,"path":"technology/yixun.html","link":"","permalink":"https://www.sakura521.cn/technology/yixun.html","excerpt":"","text":"亿寻是某爱破解论坛一个大佬写的一个工具。原文地址：https://www.52pojie.cn/thread-959139-1-1.html 作者在原文提到他是想找一个人所以才写了这个软件，在这里也希望他能早点找到他要找到的这个人。 下载地址亿寻的最新版本：https://www.lanzous.com/b00n7nu4d 使用教程 首先在网页上登陆百度云网盘网址：https://pan.baidu.com/disk/home 复制出Cookie（我使用的是谷歌浏览器）点击网址左边的小锁 在亿寻主程序登陆 设置下载默认位置 开始下载右键你要下载的文件，点直接下载然后等待片刻就会出现一个cmd窗口就是在下载 注意事项亿寻虽然是免费不限速下载，但是每天限制流量30G，但是30G对于绝大部分来说已经够了。 亿寻官网https://yixun.writeas.com/yi-xun 公众号文章连接https://mp.weixin.qq.com/s/k0uLB9VO_42rSPGTcQjp9Q 欢迎关注我新创建的公众号","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"}],"author":"小坏孩"},{"title":"一个可以做主页的导航","slug":"一个可以做主页的导航","date":"2020-03-26T07:33:05.000Z","updated":"2022-08-04T06:52:27.908Z","comments":true,"path":"technology/sakuranav.html","link":"","permalink":"https://www.sakura521.cn/technology/sakuranav.html","excerpt":"","text":"前言网上有各种各样的导航，但是总是有各种广告，而且还不知道有没有不好的后台程序。所以自己借助网上一些前端模板进行修改。写出来这个纯前端的导航 导航地址一个是放在coding一个单独的项目然后用阿里云cdn加速的网址： https://nav.sakura521.cn/ 还有一个是放在本网址的目录下面，也同样用cdn加速了的： https://www.sakura521.cn/nav/ 功能打开首先是一个大的百度搜索框。背景是渐变色，看着美观舒适。 右侧有当前天气报告。 没有广告。 有常用工具网址。 因为第一次写导航，肯定有不好的地方，有意见可以留言。 如果感觉导航里面的网址不适合你，我可以给你定制网址，当然免费。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"}],"author":"小坏孩"},{"title":"全网独家 hexo seo优化之关键词和简介的优化","slug":"全网独家-hexo-seo优化之关键词和简介的优化","date":"2020-03-20T06:18:10.000Z","updated":"2022-08-04T06:52:27.910Z","comments":true,"path":"realstuff/seokeywords.html","link":"","permalink":"https://www.sakura521.cn/realstuff/seokeywords.html","excerpt":"","text":"前言最近网站一直在内部修改，今天改的是关键词以及简介的优化。 这就是我现在网站首页的关键词和简介。 &lt;meta name=&quot;keywords&quot; content=&quot;Hexo,Sakura,JavaScript,html5,css3,Jquery,NodeJs,github,css,js,html,java&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;樱花博客，一个记录个人成长的地方。&quot;&gt; 我用的主题是Sakura（所有主题基本通用此教程），生成的每篇文章都会有keywords:和description:。但是貌似并没有用上，或者用上了我没有发现。。。 一下就是我自己研究的修改的地方。 关键词优化首先打开网站根目录下的_config.yml配置文件。找到 # Site title: 樱花🌸 subtitle: description: 樱花🌸，小坏孩的小博客 keywords: 关键词1,关键词2，关键词3 author: 小坏孩 language: zh-cn timezone: 这keywords添加的是网站的关键词。 接下来打开Hexo\\themes\\Sakura\\layout_partial\\head.ejs 别的主题也是找到这个head.ejs. 在文件中添加一下代码即可 &lt;% if (page.keywords)&#123; %&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&lt;%= page.keywords %&gt;,&lt;%= config.keywords %&gt;&quot;&gt; &lt;% &#125; else if (config.keywords)&#123; %&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&lt;%= config.keywords %&gt;&quot;&gt; &lt;%&#125; %&gt; &lt;% if (page.description)&#123; %&gt; &lt;meta name=&quot;description&quot; content=&quot;&lt;%= page.description %&gt;&quot;&gt; &lt;% &#125; else &#123; %&gt; &lt;meta name=&quot;description&quot; content=&quot;樱花博客，一个记录个人成长的地方。&quot;&gt; &lt;%&#125; %&gt; 然后构建一下就可以了 hexo g 路径优化seo优化很重要的一点就是路径。网页不能太深，原本的生成文章的路径是&#x2F;年&#x2F;月&#x2F;日&#x2F;文章 后来我也更改了一下。 首先打开网站根目录下的_config.yml配置文件。找到#URL，更改效果如下 # URL url: https://www.sakura521.cn root: / permalink: :type/:fileName.html permalink_defaults: 当然还有一种方法是用永久链接，用插件生成id。这里就不写了，因为我也没用过。 打开Hexo\\scaffolds\\post.md 在最下面添加 fileName: demo 那么这个文章就是demo.html type: test 那么这个文章路径就是 网址.com/test/demo.html 最终效果（因主题而异）： title: &#123;&#123; title &#125;&#125; date: &#123;&#123; date &#125;&#125; author: 小坏孩 avatar: &#39;https://cdn.jsdelivr.net/gh/wang1375830242/CDN@1.01/images/8972361_tiny.th.jpg&#39; authorLink: sakura521.cn authorAbout: 一个好奇的人 authorDesc: 一个好奇的人 categories: 技术 comments: true tags: keywords: description: photos: fileName: type: 这就是今天的教程 完","categories":[{"name":"干货","slug":"干货","permalink":"https://www.sakura521.cn/categories/%E5%B9%B2%E8%B4%A7/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.sakura521.cn/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://www.sakura521.cn/tags/%E6%82%A6%E8%AF%BB/"}],"author":"小坏孩"},{"title":"给新手推荐的IDEA插件 干货分享","slug":"给新手推荐的IDEA插件-干货分享","date":"2020-03-17T01:52:11.000Z","updated":"2022-08-04T06:52:27.911Z","comments":true,"path":"realstuff/IDEAPlugins.html","link":"","permalink":"https://www.sakura521.cn/realstuff/IDEAPlugins.html","excerpt":"","text":"给大家推荐几个我在用的插件毕竟我也接近于小白，感觉这几个IDEA的插件相当好用，只有实用的干货。 所有插件下载地方都在File Settings Plugins 或者使用快捷键 CTRL + ALT +S （可能与别的软件热键冲突） Translation这是个翻译插件，例如我英语非常不好，所以安装的第一个插件就是这个翻译插件。 如果选中的句子，也可以翻译句子。 Rainbow Brackets这是一个将成对的括号进行上色的一个插件，这样在复杂的代码中方便找到自己想找的地方。 效果图如下： Free Mybatis plugin这个插件方便了 mapper Java接口方法和mapper XML 来回切换。节省了翻文件查找的时间。 ![](https://cdn.jsdelivr.net/gh/wang1375830242/CDN/images/Free Mybatis plugin1.png) ![](https://cdn.jsdelivr.net/gh/wang1375830242/CDN/images/Free Mybatis plugin2.png) RestfulToolkit这个也是最近才使用的。 可以直接看出自己写了多少接口 接口的Controller代码在哪 直接进行接口测试 MyBatis Log Plugin这是一个可以将xml文件中是使用的拼装好的SQL语句进行打印。 下载好后在Tools中就可以打开这个插件了。 CodeGlance在代码旁边有个缩略图，可以直接查看定位自己代码。快速切换想看的地方。 这个我以前用，现在卸载了，感觉这个占内存有点，也不知道是不是错觉。 因为我的卸载了，我就在官方找了一张图。 Lombok这个功能可以说是太多了。可以少写很多代码，而且 方便很多，这个就不细说了，去网上搜一下，就知道这个插件的强大。","categories":[{"name":"干货","slug":"干货","permalink":"https://www.sakura521.cn/categories/%E5%B9%B2%E8%B4%A7/"}],"tags":[{"name":"干货","slug":"干货","permalink":"https://www.sakura521.cn/tags/%E5%B9%B2%E8%B4%A7/"}],"author":"小坏孩"},{"title":"编程专用字体 JetBrains Mono","slug":"编程专用字体-JetBrains-Mono","date":"2020-03-16T08:35:30.000Z","updated":"2022-08-04T06:52:27.912Z","comments":true,"path":"realstuff/JetBrainsMono.html","link":"","permalink":"https://www.sakura521.cn/realstuff/JetBrainsMono.html","excerpt":"","text":"JetBrains推出了一款专门为了开发人员设计的新字体，即JetBrains Mono。 各个语言的模板Kotlin Java Go Python C++ C# 可以说这个字体看着真的很舒服。 对比效果与其他字体对比效果 特色 符号的独特性 “ 1”，“ l”和“ I”都易于区分。 零在里面有一个点。字母“ O”不是。 逗号的形状不同于期间的形状，使它们在小尺寸时更容易区分。派生符号也是如此。 等等各种特色。对于程序员简直完美。 (adsbygoogle = window.adsbygoogle || []).push({}); 下载安装教程从v2019.3开始，JetBrains IDE随附了最新版本的JetBrains Mono。所以如果你的版本是2019.3或者以上，直接跳到使用就可以了 下载官方下载地址 安装Mac: 选择文件夹中的所有字体文件，然后双击它们。点击“安装字体”按钮。 Windows: 选择文件夹中的字体文件，右键单击其中任何一个，然后从菜单中选择“安装”。 Linux: 将字体解压缩为〜&#x2F; .local &#x2F; share &#x2F; fonts（或&#x2F; usr &#x2F; share &#x2F; fonts，以在系统范围内安装字体）并执行fc-cache -f -v 使用重启IDE，去File → Settings → Editor → Font 然后在字体下拉列表选择 JetBrains Mono。 官方字体原网址https://www.jetbrains.com/lp/mono/","categories":[{"name":"干货","slug":"干货","permalink":"https://www.sakura521.cn/categories/%E5%B9%B2%E8%B4%A7/"}],"tags":[{"name":"干货","slug":"干货","permalink":"https://www.sakura521.cn/tags/%E5%B9%B2%E8%B4%A7/"}],"author":"小坏孩"},{"title":"PicGo+jsDelivr+GitHub搭建免费cdn加速图床","slug":"PicGo-jsDelivr-GitHub搭建免费cdn图床","date":"2020-03-13T04:36:41.000Z","updated":"2022-08-04T06:52:27.902Z","comments":true,"path":"technology/picgocdn.html","link":"","permalink":"https://www.sakura521.cn/technology/picgocdn.html","excerpt":"","text":"前言开始使用GitHub＋jsDelivr搭建的cdn加速的免费图床，但是发现每次上传图片，然后创建新的版本太麻烦了。 于是借助PicGo这个工具来简化过程。 下载PicGoPicGo下载地址: https://github.com/Molunerfinn/picgo/releases 创建GitHub仓库 点自己头像，点Setting 再点Developer settings 再点Personal access tokens 填写内容，记得勾选repo 复制生成的token,（再关闭网页这个token就没法复制了） (adsbygoogle = window.adsbygoogle || []).push({}); 配置PicGo 设定自定义域名： https://cdn.jsdelivr.net/gh/wang1375830242/PicGo/ https://cdn.jsdelivr.net/gh/用户名/仓库名/ 配置完这些就可以使用了，但是要注意这个图床是任何人都能看到的，不要上传私密照片。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"}],"author":"小坏孩"},{"title":"Hexo Sakura主题美化 超详细","slug":"Hexo-Sakura主题美化-超详细","date":"2020-03-13T01:35:44.000Z","updated":"2022-08-04T06:52:27.895Z","comments":true,"path":"technology/sakurameihua.html","link":"","permalink":"https://www.sakura521.cn/technology/sakurameihua.html","excerpt":"","text":"目录和文件分析分析下themes&#x2F;Sakura目录结构和文件 首先分析下目录，主要包括以下几个 languages 这个文件夹中存放的是语言文件，主要是博客中的一些字符以简体中文、繁体中文、英文显示的定义 layout 这个是布局文件夹，所有的博客页面HTML和JavaScript以ejs模板存放在这 Search 这里存放的是页内搜索的ejs文件 _partial 这里的和下面的都是公共的页面，可以引入到HTML的任意位置 _widget source 这个文件夹和博客根目录下的source文件夹是一样的，但是为了存放主题相关的文件 css 这里存放css文件 fonts 字体文件 images 图片 js js文件 代码插入位置再接着就是需要知道我们插入的文件和代码应该放到哪里 一般来说我们的js、css代码一般以文件形式存放到js、css文件夹中，接着再引入HTML代码中，引入位置一般在&lt;head&gt;&lt;/head&gt;标签中，当然啦css、js位置也不是固定的，你也可以直接放到HTML页面结构的中央和结尾，也就是&lt;body&gt;&lt;/body&gt;之间或者&lt;/body&gt;之后、&lt;/head&gt;之前 要是CSS或者JavaScript的代码很少的话，可以直接放到HTML中，不需要先存为文件再引入 具体参考：HTML中引入js、css的三种方式——行内样式、页面中样式、外部文件导入 就对应我们现在要修改的文件中的_partial目录下head.ejs——这个&lt;html&gt;&lt;head&gt;&lt;/head&gt;就在这个文件中 footer.ejs是底部元素，一般个人、企业版权写在这里，因为一般大部分文件都会引入，因此js代码也可以写在这 layout.ejs这个也是所有页面需要引入的，因为&lt;/body&gt;&lt;/html&gt;标签在这里 要是想将功能单独添加到某个页面，那你就找到那个ejs文件放到里面就醒了 博客原有功能的修改博客原有功能修改主要指的是博客根目录配置文件和主题配置文件的修改 因为大部分的都已经在上次的博客搭建文章中写了 就不多说了吧 主要包括各种页面结构的修改： 首页轮播图 站点图标、头像、赞赏等图片的链接修改 个人化的站点标题、副标题、描述、关键词等 导航栏的修改、添加、删除等 通知的修改 startdash的图片、链接修改 社交链接的修改等 这上面这些应该都是不需要再讲了的 (adsbygoogle = window.adsbygoogle || []).push({}); 导航栏中的关于主要是关于&gt;我？这个的修改 这个要修改的文件在Sakura&#x2F;source&#x2F;js目录下，名字为botui.js 主要修改content后面双引号里的内容，自行修改为自己的就行 导航栏中的客户端这个可以使用Fusion App把你自己的博客封装成APP 然后放到蓝奏云上，生成二维码放上来 导航栏中的RSS根目录下的配置文件中已经有了 #RSS feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: &#39; &#39; order_by: -date 这些代码 因此我们只需要安装好插件就行了 npm install hexo-generator-feed 当然啦，如果本来就能显示内容，那么就不需要安装了 每个页面中的顶部图片就比如关于&gt;主题这个页面 我们进入根目录下，再进入source目录找到theme-sakura，进入该目录点击index.md，修改photos后面的内容，改为你想要的图片链接 ---title: theme-sakura comments: false date: 2019-01-04 22:53:25 keywords: Hexo 主题 Sakura 🌸 description:photos: https://static.2heng.xin/wp-content/uploads//2018/05/sakura2.jpeg ---Hexo主题Sakura修改自WordPress主题[Sakura](https://github.com/mashirozx/Sakura/)，感谢原作者[Mashiro](https://2heng.xin/) 文章上面和首页文章列表的图片也是修改的你新建的文章中的photos后面的图片链接 这些都是这个主题支持的内容，在上篇文章中写过的文章模板 --- title: 文章标题 author: 作者名 avatar: 作者头像链接 authorLink: hojun.cn #作者的域名 authorAbout: 一个好奇的人 #关于 authorDesc: 一个好奇的人 #作者描述 categories: 分类 date: 2018-12-12 22:16:01 #时间，这个一般都自动创建 comments: true # 是否需要留言 tags: # 下面可以写多个标签 - web - 悦读 keywords: Sakura # 文章关键词 description: hexo-sakura主题使用教程 #文章描述 photos: https://static.2heng.xin/wp-content/uploads//2019/02/wallhaven-672007-1-1024x576.png --- 清单下的番组这个是在source下bangumi下的index.md中修改的 --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番的图片 title: 朝花夕誓——于离别之朝束起约定之花 # 番的中文标题 status: 已追完 # 追番状态 progress: 100 # 追番进度 jp: さよならの朝に約束の花をかざろう # 日文标题 time: 2018-02-24 SUN. # 这个是出版的时间 desc: 这里是你追的番的描述 --- (adsbygoogle = window.adsbygoogle || []).push({}); 清单下的歌单和左下角悬浮歌单主要是修改你的id，歌单id的获取方式： 进入网易云网页版https://music.163.com/ 登录账号，选择一个歌单打开 浏览器的链接将会显示id，就最后一个字段，把那些数字复制到下面就行 https://music.163.com/?from=infinity#/playlist?id=2162711186 清单下的歌单文件是source&#x2F;music&#x2F;index.md --- title: music date: 2018-12-20 23:14:28 keywords: 喜欢的音乐 description: comments: false photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/music.jpg --- 修改这里就可以 悬浮音乐的代码在主题配置文件中 aplayer: id: 2660651585 server: netease type: playlist fixed: true autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true 友链添加友链修改文件在source&#x2F;links&#x2F;index.md --- layout: links title: links date: 2018-12-19 23:11:06 keywords: 友人帐 description: comments: true photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg links: - group: 个人项目 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: ## 友链添加主要是在这里 - url: https://shino.cc/fgvf # 他的链接 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 他的头像 name: Google # 他的博客名 desc: Google 镜像 # 博客描述 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 不需要修改layout目录下文件的应该就这些了 接下来就直接按点添加功能和美化了 添加标题恶搞默认的是离开时候还是现实自己的文字标题 添加之后离开和回到这个页面时显示 为了达到上述效果,我们可以在head.ejs或者footer.ejs中加入代码 &lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/js/hititle.js&quot;&gt;&lt;/script&gt; 例如加入到head.ejs的该位置 加入之后刷新就能生效了 鼠标点击特效单击特效有很多种，这里给出三个吧 现在我们把这个代码放到layout.ejs的&#96;&#96;标签前 &lt;!-- 点击出现社会主义彩色文字 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/shehuizhuyi.js&quot;&gt;&lt;/script&gt;&lt;!-- 点击出现爱心 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/love.js&quot;&gt;&lt;/script&gt;&lt;!-- 点击出现彩色气球爆炸效果 --&gt;&lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/clickBom.js&quot;&gt;&lt;/script&gt; 可以分别添加一种，也可以多种混合，但是三种一起使用感觉效果不太好 下面是前两者结合的效果： 最后一种： 这个有很多个，这里展示一个 把代码插入到layout.ejs中 &lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/xuehua.js&quot;&gt;&lt;/script&gt; 效果如下： 背景显示飘动的彩带在需要的页面添加，我们还是在所有页面都加上，layout.ejs中加入代码 &lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/piao.js&quot;&gt;&lt;/script&gt; 背景添加动态线条，随鼠标动仍是layout.ejs中 &lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/canvas-nest.min.js&quot;&gt;&lt;/script&gt; 樱花飘落或雪花飘落仍是layout.ejs中 樱花飘落： &lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/sakura.js&quot;&gt;&lt;/script&gt; 雪花飘落： &lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/xuehuapiaoluo.js&quot;&gt;&lt;/script&gt;或者&lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/snow.js&quot;&gt;&lt;/script&gt; 选择一个就行了 (adsbygoogle = window.adsbygoogle || []).push({}); 禁用一些按键为了阻止某些使用F12、Ctrl+Alt+I调用开发者选项的用户 还有禁用了鼠标右键，可以开启禁用鼠标左键拖动选择文字 &lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/noSomeKey.js&quot;&gt;&lt;/script&gt; 添加画板娘这次不用插件来添加，直接引入js代码 &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;&gt; &lt;!-- 这条在sakura中已有，可不添加 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js&quot;&gt;&lt;/script&gt; 仓库链接在这： live2d-widget https://github.com/stevenjoezhang/live2d-widget 添加前往GitHub的彩带前往 GitHub Ribbons https://github.blog/2008-12-19-github-ribbons/ 挑选样式之后，复制相应的代码，粘贴到合适的地方 加入预加载sakura主题集成了图片懒加载，可是页面放到GitHub加载还是很慢，matery主题就加入了预加载，从那里得到灵感，因此我们加入预加载 还是在layout.ejs中添加 &lt;script src=&quot;//instant.page/3.0.0&quot; type=&quot;module&quot; defer integrity=&quot;sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1&quot;&gt;&lt;/script&gt; 官网在这：预加载https://instant.page/ 添加计数主要使用的是不蒜子和LeanCloud LeanCloud我使用起来并不理想，因此不讲，想要了解自己去官网看 不蒜子的： &lt;script src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 再进入不蒜子官网查看访问量pv、用户访问量uv使用 添加一言API、诗词今日诗词 https://www.jinrishici.com/# 提供了诗词的API 我们将这个诗词放到以前的描述那里，社交图标的上方 修改headertop.ejs，找到下面的代码 &lt;div class=&quot;header-info&quot;&gt; &lt;!-- 找到这个位置 --&gt; &lt;!-- &lt;p&gt;&lt;%= theme.description %&gt;&lt;/p&gt; --&gt; 把这句注释掉 &lt;p id=&quot;jinrishici-sentence&quot;&gt;正在加载今日诗词....&lt;/p&gt; &lt;script src=&quot;https://sdk.jinrishici.com/v2/browser/jinrishici.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;!-- 添加上面的两句 --&gt; &lt;div class=&quot;top-social_v2&quot;&gt; 一言API的可以前往这个网址查看使用： 一言开发者中心 https://developer.hitokoto.cn/sentence/ 正好通知也没有啥用，把他换掉 进入index.ejs，查找&lt;%= theme.notice%&gt;，将其替换为下面的 &lt;span id=&quot;hitokoto&quot; style=&quot;margin-left:5px;&quot;&gt; :D 获取中...&lt;/span&gt; &lt;p align=&quot;right&quot; id=&quot;afrom&quot;&gt;&lt;/p&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; fetch(&#39;https://v1.hitokoto.cn/?c=h&#39;) .then(function (res)&#123; return res.json(); &#125;) .then(function (data) &#123; var hitokoto = document.getElementById(&#39;hitokoto&#39;); var afrom = document.getElementById(&#39;afrom&#39;); hitokoto.innerText = data.hitokoto; afrom.innerText = &#39;——【&#39; + data.from + &#39; &#39; + data.from_who + &#39;】&#39;; &#125;) .catch(function (err) &#123; console.error(err); &#125;) &lt;/script&gt; 添加底部的网站运行时间在footer.ejs选择合适位置添加代码 &lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date(&quot;03/08/2020 16:44:00&quot;);//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; &#125; setInterval(&quot;createtime()&quot;,250);&lt;/script&gt; 添加底部动态滚动文字&lt;div id=&quot;binft&quot;&gt;&lt;/div&gt; &lt;script&gt; var binft = function (r) &#123; function t() &#123; return b[Math.floor(Math.random() * b.length)] &#125; function e() &#123; return String.fromCharCode(94 * Math.random() + 33) &#125; function n(r) &#123; for (var n = document.createDocumentFragment(), i = 0; r &gt; i; i++) &#123; var l = document.createElement(&quot;span&quot;); l.textContent = e(), l.style.color = t(), n.appendChild(l) &#125; return n &#125; function i() &#123; var t = o[c.skillI]; c.step ? c.step-- : (c.step = g, c.prefixP &lt; l.length ? (c.prefixP &gt;= 0 &amp;&amp; (c.text += l[c.prefixP]), c.prefixP++) : &quot;forward&quot; === c.direction ? c.skillP &lt; t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = &quot;backward&quot;, c.delay = a) : c.skillP &gt; 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = &quot;forward&quot;)), r.textContent = c.text, r.appendChild(n(c.prefixP &lt; l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d) &#125; var l = &quot;&quot;, o = [&quot;青青陵上柏，磊磊涧中石。&quot;, &quot;人生天地间，忽如远行客。&quot;,&quot;斗酒相娱乐，聊厚不为薄。&quot;, &quot;驱车策驽马，游戏宛与洛。&quot;,&quot;洛中何郁郁，冠带自相索。&quot;,&quot;长衢罗夹巷，王侯多第宅。&quot;,&quot;两宫遥相望，双阙百余尺。&quot;,&quot;极宴娱心意，戚戚何所迫？&quot;].map(function (r) &#123; return r + &quot;&quot; &#125;), a = 2, g = 1, s = 5, d = 75, b = [&quot;rgb(110,64,170)&quot;, &quot;rgb(150,61,179)&quot;, &quot;rgb(191,60,175)&quot;, &quot;rgb(228,65,157)&quot;, &quot;rgb(254,75,131)&quot;, &quot;rgb(255,94,99)&quot;, &quot;rgb(255,120,71)&quot;, &quot;rgb(251,150,51)&quot;, &quot;rgb(226,183,47)&quot;, &quot;rgb(198,214,60)&quot;, &quot;rgb(175,240,91)&quot;, &quot;rgb(127,246,88)&quot;, &quot;rgb(82,246,103)&quot;, &quot;rgb(48,239,130)&quot;, &quot;rgb(29,223,163)&quot;, &quot;rgb(26,199,194)&quot;, &quot;rgb(35,171,216)&quot;, &quot;rgb(54,140,225)&quot;, &quot;rgb(76,110,219)&quot;, &quot;rgb(96,84,200)&quot;], c = &#123; text: &quot;&quot;, prefixP: -s, skillI: 0, skillP: 0, direction: &quot;forward&quot;, delay: a, step: g &#125;; i() &#125;; binft(document.getElementById(&#39;binft&#39;)); &lt;/script&gt; 加入天气插件前往 中国天气 https://cj.weather.com.cn/plugin/pc 这个网址查看详情 可以选用小视图，添加到link.ejs中 顶部加载条这个sakura有，但是想记录一下 head中加入 &lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; (adsbygoogle = window.adsbygoogle || []).push({}); 修改鼠标样式在style.css中添加,sakura已有，可不管，当然啦，也可以去找一下其他好看的图标 // 鼠标样式 * &#123; cursor: url(&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/cursor/normal.cur&quot;),auto!important &#125; :active &#123; cursor: url(&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn@latest/img/cursor/No_Disponible.cur&quot;),auto!important &#125; 评论系统sakura自带的系统为valine，我们可以自行替换成其他的 就比如来必力，前往 来必力官网 https://www.livere.com/ 注册登录后，点击菜单栏的【安装】，出现这个界面，直接点击【现在安装】 前往管理页，点击左边的【代码管理】 你将会看到这样的代码 data-uid后面的双引号中的内容剪切出来 然后到主题配置文件下修改，找到最下面的valine 将valine改成false，添加最后两行 # Valine valine: false v_appId: Cu2IPPUW8BnkmwzFa8WrS9VC-gzGzoHsz v_appKey: kgcNfaHXq91mfCaAIcbjGChl # livere livere: true data_uid: 刚刚复制的uid 接着把下面的代码复制到comment.ejs中 &lt;% if (theme.livere &amp;&amp; post.comments) &#123; %&gt;&lt;!-- 来必力City版安装代码 --&gt;&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;&lt;%= theme.livere.data_uid %&gt;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &#39;function&#39;) &#123; return; &#125; j = d.createElement(s); j.src = &#39;https://cdn-city.livere.com/js/embed.dist.js&#39;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &#39;script&#39;);&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- Ci 在线联系DaoVoice 在线联系 前往网站 DaoVoice https://www.daovoice.io/ 可以使用GitHub或者微信登录，也可以前往 这里注册 http://dashboard.daovoice.io/get-started 进入之后点击应用设置，再点击安装到网站 再将第一个代码复制到&#96;&#96;之前，将下面两个复制到layout.ejs 添加优美的标签页这个标签页和分类页提取自matery，不得不说matery真的很漂亮 首先我们要创建几个文件，文件所在目录如下 layout tags.ejs _widget tag-cloud.ejs tag-wordcloud.ejs 也就是tags.ejs放在layout根目录下，下面两个文件放在layout子目录_widget下 tags.ejs &lt;%- partial(&#39;_partial/header&#39;) %&gt; &lt;main class=&quot;content&quot;&gt; &lt;%- partial(&#39;_widget/tag-cloud&#39;) %&gt; &lt;%- partial(&#39;_widget/tag-wordcloud&#39;) %&gt; &lt;/main&gt; _widget&#x2F;tag-cloud.ejs &lt;% var colorArr = [&#39;#F9EBEA&#39;, &#39;#F5EEF8&#39;, &#39;#D5F5E3&#39;, &#39;#E8F8F5&#39;, &#39;#FEF9E7&#39;, &#39;#F8F9F9&#39;, &#39;#82E0AA&#39;, &#39;#D7BDE2&#39;, &#39;#A3E4D7&#39;, &#39;#85C1E9&#39;, &#39;#F8C471&#39;, &#39;#F9E79F&#39;, &#39;#FFF&#39;]; var colorCount = colorArr.length; var hashCode = function (str) &#123; if (!str &amp;&amp; str.length === 0) &#123; return 0; &#125; var hash = 0; for (var i = 0, len = str.length; i &lt; len; i++) &#123; hash = ((hash &lt;&lt; 5) - hash) + str.charCodeAt(i); hash |= 0; &#125; return hash; &#125;; var i = 0; var isTag = is_tag(); %&gt; &lt;div id=&quot;tags&quot; class=&quot;container chip-container&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-content&quot;&gt; &lt;div class=&quot;tag-title center-align&quot;&gt; &lt;i class=&quot;fa fa-tags&quot;&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;文章标签 &lt;/div&gt; &lt;div class=&quot;tag-chips&quot;&gt; &lt;% site.tags.map(function(tag) &#123; %&gt; &lt;% i++; var color = i &gt;= colorCount ? colorArr[Math.abs(hashCode(tag.name) % colorCount)] : colorArr[i - 1]; %&gt; &lt;a href=&quot;&lt;%- url_for(tag.path) %&gt;&quot; title=&quot;&lt;%- tag.name %&gt;: &lt;%- tag.length %&gt;&quot;&gt; &lt;span class=&quot;chip center-align waves-effect waves-light &lt;% if (isTag &amp;&amp; tag.name == page.tag) &#123; %&gt; chip-active &lt;% &#125; else &#123; %&gt; chip-default &lt;% &#125; %&gt;&quot; data-tagname=&quot;&lt;%- tag.name %&gt;&quot; style=&quot;background-color: &lt;%- color %&gt;;&quot;&gt;&lt;%- tag.name %&gt; &lt;span class=&quot;tag-length&quot;&gt;&lt;%- tag.length %&gt;&lt;/span&gt; &lt;/span&gt; &lt;/a&gt; &lt;% &#125;); %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; _widget&#x2F;tag-wordcloud.ejs &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/css/jqcloud.css&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; #tag-wordcloud &#123; width: 100%; height: 300px; &#125; &lt;/style&gt; &lt;div class=&quot;container&quot; data-aos=&quot;fade-up&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div id=&quot;tag-wordcloud&quot; class=&quot;card-content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/jqcloud-1.0.4.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; &lt;% let tagWordArr = []; site.tags.map(function(tag) &#123; tagWordArr.push(&#123;&#39;text&#39;: tag.name, &#39;weight&#39;: tag.length, &#39;link&#39;: tag.permalink&#125;); &#125;); let tagWords = JSON.stringify(tagWordArr); %&gt; $(&#39;#tag-wordcloud&#39;).jQCloud(&lt;%- tagWords %&gt;, &#123; autoResize: true &#125;); &lt;/script&gt; 将这段代码复制到style.css末尾 .chip-container &#123; margin-top: 60px;&#125;.chip-container .tag-title &#123; margin-bottom: 10px; color: #3C4858; font-size: 1.75rem; font-weight: 400;&#125;.chip-container .tag-chips &#123; margin: 1rem auto 0.5rem; max-width: 850px; text-align: center;&#125;.chip-container .tags-posts &#123; margin-top: 20px;&#125;.chip-container .chip-default &#123; color: #34495e;&#125;.chip-container .chip-active &#123; color: #FFF !important; background: linear-gradient(to bottom right, #FF5E3A 0%, #FF2A68 100%) !important; box-shadow: 2px 5px 10px #aaa !important;&#125;.chip-container .chip &#123; margin: 10px 10px; padding: 19px 14px; display: inline-flex; line-height: 0; font-size: 1rem; font-weight: 500; border-radius: 5px; cursor: pointer; box-shadow: 0 3px 5px rgba(0, 0, 0, .12);&#125;.chip-container .chip:hover &#123; color: #fff; background: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%) !important;&#125;.chip .tag-length &#123; margin-left: 5px; margin-right: -2px; font-size: 0.5rem;&#125;.chip-default .tag-length &#123; color: #e91e63; margin-top: 1px;&#125;.chip-active .tag-length &#123; color: #fff;&#125;.tag-title.center-align&#123; margin-top: 100px; text-align : center;&#125; 使用命令hexo new page &quot;tags&quot;，修改博客根目录下source&#x2F;tags&#x2F;index.md --- title: tags date: 2020-03-09 13:50:05 layout: tags --- 在 http://localhost:4000/tags查看页面 添加优美的分类页 接着创建几个文件，文件所在目录如下 layout categories.ejs _widget category-cloud.ejs category-radar.ejs 也就是categories.ejs放在layout根目录下，下面两个文件放在layout子目录_widget下 添加代码 categories.ejs &lt;%- partial(&#39;_partial/header&#39;) %&gt; &lt;main class=&quot;content&quot;&gt; &lt;%- partial(&#39;_widget/category-cloud&#39;) %&gt; &lt;% if (site.categories &amp;&amp; site.categories.length &gt; 0) &#123; %&gt; &lt;%- partial(&#39;_widget/category-radar&#39;) %&gt; &lt;% &#125; %&gt; &lt;/main&gt; category-cloud.ejs &lt;% var colorArr = [&#39;#F9EBEA&#39;, &#39;#F5EEF8&#39;, &#39;#D5F5E3&#39;, &#39;#E8F8F5&#39;, &#39;#FEF9E7&#39;, &#39;#F8F9F9&#39;, &#39;#82E0AA&#39;, &#39;#D7BDE2&#39;, &#39;#A3E4D7&#39;, &#39;#85C1E9&#39;, &#39;#F8C471&#39;, &#39;#F9E79F&#39;, &#39;#FFF&#39;]; var colorCount = colorArr.length; var hashCode = function (str) &#123; if (!str &amp;&amp; str.length === 0) &#123; return 0; &#125; var hash = 0; for (var i = 0, len = str.length; i &lt; len; i++) &#123; hash = ((hash &lt;&lt; 5) - hash) + str.charCodeAt(i); hash |= 0; &#125; return hash; &#125;; var i = 0; var isCategory = is_category(); %&gt; &lt;div id=&quot;category-cloud&quot; class=&quot;container chip-container&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-content&quot;&gt; &lt;div class=&quot;tag-title center-align&quot;&gt; &lt;i class=&quot;fa fa-bookmark&quot;&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;文章分类 &lt;/div&gt; &lt;div class=&quot;tag-chips&quot;&gt; &lt;% if (site.categories &amp;&amp; site.categories.length &gt; 0) &#123; %&gt; &lt;% site.categories.map(function(category) &#123; %&gt; &lt;% i++; var color = i &gt;= colorCount ? colorArr[Math.abs(hashCode(category.name) % colorCount)] : colorArr[i - 1]; %&gt; &lt;a href=&quot;&lt;%- url_for(category.path) %&gt;&quot; title=&quot;&lt;%- category.name %&gt;: &lt;%- category.length %&gt;&quot;&gt; &lt;span class=&quot;chip center-align waves-effect waves-light &lt;% if (isCategory &amp;&amp; category.name == page.category) &#123; %&gt; chip-active &lt;% &#125; else &#123; %&gt; chip-default &lt;% &#125; %&gt;&quot; style=&quot;background-color: &lt;%- color %&gt;;&quot;&gt;&lt;%- category.name %&gt; &lt;span class=&quot;tag-length&quot;&gt;&lt;%- category.length %&gt;&lt;/span&gt; &lt;/span&gt; &lt;/a&gt; &lt;% &#125;); %&gt; &lt;% &#125; else &#123; %&gt; &lt;%= __(&#39;categoryEmptyTip&#39;) %&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; category-radar.ejs &lt;style type=&quot;text/css&quot;&gt; #category-radar &#123; margin-top: 50px; width: 100%; height: 360px; &#125; &lt;/style&gt; &lt;div class=&quot;container&quot; data-aos=&quot;fade-up&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div id=&quot;category-radar&quot; class=&quot;card-content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/echarts.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; let radarChart = echarts.init(document.getElementById(&#39;category-radar&#39;)); &lt;% var categories = site.categories; // Find the maximum and average values of the post categories. var radarValueArr = []; categories.some(function(category) &#123; radarValueArr.push(category.length); &#125;); var max = Math.max.apply(null, radarValueArr) + Math.min.apply(null, radarValueArr); // Calculate the data needed for the radar chart. var indicatorArr = []; categories.map(function(category) &#123; indicatorArr.push(&#123;&#39;name&#39;: category.name, &#39;max&#39;: max&#125;); &#125;); var indicatorData = JSON.stringify(indicatorArr); var radarValueData = JSON.stringify(radarValueArr); %&gt; let option = &#123; title: &#123; left: &#39;center&#39;, text: &#39;文章分类雷达图&#39;, textStyle: &#123; fontWeight: 500, fontSize: 22 &#125; &#125;, tooltip: &#123;&#125;, radar: &#123; name: &#123; textStyle: &#123; color: &#39;#3C4858&#39; &#125; &#125;, indicator: &lt;%- indicatorData %&gt;, nameGap: 5, center: [&#39;50%&#39;,&#39;55%&#39;], radius: &#39;66%&#39; &#125;, series: [&#123; type: &#39;radar&#39;, color: [&#39;#3ecf8e&#39;], itemStyle: &#123;normal: &#123;areaStyle: &#123;type: &#39;default&#39;&#125;&#125;&#125;, data : [ &#123; value : &lt;%- radarValueData %&gt;, name : &#39;文章分类数量&#39; &#125; ] &#125;] &#125;; radarChart.setOption(option); &lt;/script&gt; 接着用命令hexo new page &quot;categories&quot;创建分类页 修改博客根目录下source&#x2F;categories&#x2F;index.md --- title: categories date: 2020-03-09 13:50:05 layout: categories --- http://localhost:4000/categories 查看 接着就是把这两个页面放到导航栏上面去 修改主题配置文件，将这两行代码放到留言板之前 标签: &#123;path: /tags/, fa: fa-tag &#125; 分类: &#123;path: /categories/, fa: fa-bookmark &#125; (adsbygoogle = window.adsbygoogle || []).push({}); 已经集成的一些插件emoji表情： hexo-filter-github-emojis https://github.com/crimx/hexo-filter-github-emojis 正常插件安装版画板娘： hexo-helper-live2d https://github.com/EYHN/hexo-helper-live2d 图片懒加载(sakura已经有了，但不是这种方式)： hexo-lazyload-image https://www.npmjs.com/package/hexo-lazyload-image hexo-lazyload-image-enhance https://github.com/barretlee/hexo-lazyload-image-enhance 字数统计(好像没装)： hexo-wordcount https://github.com/willin/hexo-wordcount fancybox： hexo-tag-fancybox_img https://github.com/honjun/hexo-tag-fancybox_img bilibili： hexo-tag-bili https://github.com/honjun/hexo-tag-bili 文章末尾版权信息添加首先我们在_partial目录下新建文件article_copyright.ejs &lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;%= post.title %&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章字数:&lt;/span&gt;&lt;span class=&quot;post-count&quot;&gt;&lt;%=wordcount(post.content) %&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a title=&quot;&lt;%=config.author%&gt;&quot;&gt;&lt;%=config.author%&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&lt;%= post.date.format(&quot;YYYY-MM-DD, HH:mm:ss&quot;) %&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&lt;%= post.updated.format(&quot;YYYY-MM-DD, HH:mm:ss&quot;) %&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;post-url&quot; href=&quot;&lt;%- url_for(post.path) %&gt;&quot; title=&quot;&lt;%= post.title %&gt;&quot;&gt;&lt;%= post.permalink %&gt;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var clipboard = new Clipboard(&#39;.fa-clipboard&#39;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&#39;success&#39;, function()&#123; swal(&#123; title: &quot;&quot;, text: &#39;复制成功&#39;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt; 需要文章字数的，一定要先安装字数统计插件，上面列出了，不用就把那行注释掉 接着将下面的代码 &lt;% if (post.copyright) &#123; %&gt; &lt;%- partial(&#39;../_partial/article_copyright&#39;) %&gt; &lt;% &#125; %&gt; 复制到common-article.ejs的这个位置 将CSS代码复制到style.css中 .my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4); &#125; .my_post_copyright p&#123;margin:0;&#125; .my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold; &#125; .my_post_copyright .raw &#123; margin-left: 1em; width: 5em; &#125; .my_post_copyright a &#123; color: #808080; border-bottom:0; &#125; .my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline; &#125; .my_post_copyright:hover .fa-clipboard &#123; color: #000; &#125; .my_post_copyright .post-url:hover &#123; font-weight: normal; &#125; .my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125; &#125; .my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer; &#125; 添加404页面在博客根目录的source目录下新建404.html 随便找个模板，在开头加入代码 --- layout: false --- 例如 --- layout: false ---&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0&quot;&gt;&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;&lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;404页面&lt;/p&gt; &lt;a&gt;返回主页&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 部署到GitHub之后，访问不存在的页面就会跳出来了 域名绑定在博客根目录下的source目录下新建CNAME文件，如果主题source目录下有这个文件请删除 修改CNAME文件，内容为你的域名，例如我的 www.sakura521.cn 接着去GitHub pages更改域名，开启SSL 前往阿里云的的域名解析页面添加CANME解析 @ → 用户名.github.io 之后就可以以新的域名访问了 https://www.sakura521.cn 网站收录主要是向各大搜索引擎提交链接 谷歌收录 360站长平台 http://zhanzhang.so.com/sitetool/site_manage 百度搜索资源平台 https://ziyuan.baidu.com/linksubmit/ 百度的需要注意一下，由于GitHub将百度封了，因此你需要把博客双线部署到gitlab或coding才能收录 搜狗站长平台 http://zhanzhang.sogou.com/ 网站分析百度统计前往百度统计官网 Baidu统计 https://tongji.baidu.com/web/welcome/login 以百度账号登录后，点击【管理】，在【网站列表】中新增网站 获取代码，将代码复制到标签前，进行代码检测 以后就可以查看访问情况了 cnzz点击 友盟+ https://passport.umeng.com/login?appId=cnzz 前往，注册登录后，添加站点 根据自己喜好获取代码 粘贴到前 之后就可以点击查看信息了 小技巧博客备份有一个博客备份插件 hexo-git-backup https://github.com/coneycode/hexo-git-backup 能够传到backup分支 我们还可以把整个博客文件夹上传到GitHub私有仓库 本地预览使用命令换个端口预览hexo s -p 5000 也可以添加下列代码到博客配置文件中,使用hexo s时将会以5000端口运行 server: port: 5000 compress: true header: true 快捷命令alias设置命令别名，将下面代码复制到***.bashrc***文件中 alias hs=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&#39; alias hd=&#39;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d&#39; alias gp=&#39;git add . &amp;&amp; git commit -m &quot;update&quot; &amp;&amp; git push -f&#39; 以后输入hs命令就可以本地预览、hd部署、gp上传到仓库 静态资源压缩博客使用了图片懒加载和预加载虽然加快了一点速度，但访问还是有点慢 那么直接把html、css、js代码中的空格去掉，进行压缩 还有压缩一下图片，能够一定程度上缩小public文件夹的大小 参考这篇文章： Hexo博客使用gulp压缩静态资源 安装全局gulp npm install gulp -g 安装插件 npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp gulp-imagemin --save # 解决【Gulp打包问题】 GulpUglifyError: unable to minify JavaScript # 解决 gulp-uglify 压缩JavaScript 不兼容 es5 语法的问题 npm install babel-core@6.26.3 --save npm install gulp-babel@7.0.1 --save npm install babel-preset-es2015@6.24.1 --save # gulp-babel 取消严格模式方法(&quot;use strict&quot;) npm install babel-plugin-transform-remove-strict-mode --save 问题：如果安装gulp-imagemin错误请执行以下语句sudo npm i gulp-imagemin --unsafe-perms 博客根目录创建gulpfile.js 上面文章中有一句在这个版本会报错，已修改 var gulp = require(&#39;gulp&#39;);var minifycss = require(&#39;gulp-minify-css&#39;);var uglify = require(&#39;gulp-uglify&#39;);var htmlmin = require(&#39;gulp-htmlmin&#39;);var htmlclean = require(&#39;gulp-htmlclean&#39;);var imagemin = require(&#39;gulp-imagemin&#39;);var babel = require(&#39;gulp-babel&#39;);// 压缩css文件gulp.task(&#39;minify-css&#39;, function (done) &#123; return gulp.src(&#39;./public/**/*.css&#39;) .pipe(minifycss()) .pipe(gulp.dest(&#39;./public&#39;)); done(); &#125;);// 压缩html文件gulp.task(&#39;minify-html&#39;, function (done) &#123; return gulp.src(&#39;./public/**/*.html&#39;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&#39;./public&#39;)); done(); &#125;);// 压缩js文件gulp.task(&#39;minify-js&#39;, function (done) &#123; return gulp.src([&#39;./public/**/*.js&#39;, &#39;!./public/**/*.min.js&#39;]) .pipe(babel(&#123; //将ES6代码转译为可执行的JS代码 presets: [&#39;es2015&#39;] // es5检查机制 &#125;)) .pipe(uglify()) .pipe(gulp.dest(&#39;./public&#39;)); done(); &#125;);// 压缩 public/images 目录内图片(Version&lt;3)// gulp.task(&#39;minify-images&#39;, function () &#123;// gulp.src(&#39;./public/images/**/*.*&#39;)// .pipe(imagemin(&#123;// optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级）// progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片// interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染// multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化// &#125;))// .pipe(gulp.dest(&#39;./public/images&#39;));// &#125;);// 压缩 public/images 目录内图片(Version&gt;3)gulp.task(&#39;minify-images&#39;, function (done) &#123; gulp.src(&#39;./public/images/**/*.*&#39;) .pipe(imagemin([ imagemin.gifsicle(&#123;interlaced: true&#125;), // imagemin.jpegtran(&#123;progressive: true&#125;), // 版本升级，改用下面这个 imagemin.mozjpeg(&#123;progressive: true,&#125;), imagemin.optipng(&#123;optimizationLevel: 5&#125;), imagemin.svgo(&#123; plugins: [ &#123;removeViewBox: true&#125;, &#123;cleanupIDs: false&#125; ] &#125;) ])) .pipe(gulp.dest(&#39;./public/images&#39;)); done(); &#125;);//4.0以前的写法 //gulp.task(&#39;default&#39;, [// &#39;minify-html&#39;, &#39;minify-css&#39;, &#39;minify-js&#39;, &#39;minify-images&#39;//]);//4.0以后的写法// 执行 gulp 命令时执行的任务gulp.task(&#39;default&#39;, gulp.series(gulp.parallel(&#39;minify-html&#39;, &#39;minify-css&#39;, &#39;minify-js&#39;, &#39;minify-images&#39;)), function () &#123; console.log(&quot;----------gulp Finished----------&quot;); // Do something after a, b, and c are finished.&#125;); 根目录下创建.babelrc &#123; &#39;presets&#39;: [&#39;es2015&#39;], &quot;plugins&quot;: [&quot;transform-remove-strict-mode&quot;] &#125; (adsbygoogle = window.adsbygoogle || []).push({}); 转载源地址https://mp.weixin.qq.com/s/OAyOA28-bTJLE6aKtzpoqg","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"}],"author":"小坏孩"},{"title":"Node.js(Windows) 安装详细教程","slug":"Node-js-Windows-安装详细教程","date":"2020-03-12T07:56:03.000Z","updated":"2022-08-04T06:52:27.901Z","comments":true,"path":"technology/nodeTutorial.html","link":"","permalink":"https://www.sakura521.cn/technology/nodeTutorial.html","excerpt":"","text":"下载Node稳定版 官网下载地址 安装安装的时候也是一路next即可。 安装完成后检验，在cmd窗口输入 node -v npm -v 显示结果如下代表安装成功 (adsbygoogle = window.adsbygoogle || []).push({}); 配置环境变量首先在NodeJs下建立”node_global”及”node_cache”两个文件夹 打开cmd，输入 npm config set prefix &quot;你的路径\\nodejs\\node_global&quot; npm config set cache &quot;你的路径\\nodejs\\node_cache&quot; 然后关闭cmd窗口（不关后面可能不行） 右键我的电脑-属性-高级系统设置-高级-环境变量 在系统变量下新建“NODE_PATH”,变量值填写 你的路径\\nodejs\\node_global\\node_modules 在变量path新建新的路径 做到这就算完成了。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"}],"author":"小坏孩"},{"title":"Git安装教程(Windows) 以及连接Github","slug":"Git安装教程-Windows","date":"2020-03-12T07:11:30.000Z","updated":"2022-08-04T06:52:27.894Z","comments":true,"path":"technology/gitTutorial.html","link":"","permalink":"https://www.sakura521.cn/technology/gitTutorial.html","excerpt":"","text":"Git在Windows上安装可以说非常简单。 官方说明的windows如何安装在 Windows 上安装 Git 也有几种安装方法。 官方版本可以在 Git 官方网站下载。 打开 https://git-scm.com/download/win，下载会自动开始。 要注意这是一个名为 Git for Windows 的项目（也叫做 msysGit），和 Git 是分别独立的项目；更多信息请访问 http://msysgit.github.io/。 要进行自动安装，你可以使用 Git Chocolatey 包。 注意 Chocolatey 包是由社区维护的。 另一个简单的方法是安装 GitHub Desktop。 该安装程序包含图形化和命令行版本的 Git。 它也能支持 Powershell，提供了稳定的凭证缓存和健全的换行设置。 稍后我们会对这方面有更多了解，现在只要一句话就够了，这些都是你所需要的。 你可以在 GitHub for Windows 网站下载，网址为 GitHub Desktop 网站。 下载Git 下载地址：https://git-scm.com/download 下载Windows版本即可。 安装官方下载的可以说是自动安装，一路next即可。 检查git是否安装成功在cmd窗口中，输入git显示 到这里Git就按照完毕了。 Git连接Github首先在Github上注册一个账号。（手动狗头） 在右键菜单里点Git Bash Here 在打开的窗口输入，设置user.name和user.email配置信息 git config --global user.name &quot;你的GitHub用户名&quot; git config --global user.email &quot;你的GitHub注册邮箱&quot; 然后生成ssh密钥文件 ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 然后三个回车就可以了。 (adsbygoogle = window.adsbygoogle || []).push({}); 然后在C:\\Users\\admin.ssh文件夹中找到id_rsa.pub,将里面所有的内容全部复制出来。 在这个网址https://github.com/settings/keys点New SSH key Title随便输入，Key粘贴刚才复制的key,然后点击Add SSH key 验证一下是否连接成功 在Git Bash中输入 ssh git@github.com 如果显示下面这样就是成功了 教程完","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"}],"author":"小坏孩"},{"title":"Hexo博客 搭建超详细教程","slug":"hexo博客-搭建超详细教程","date":"2020-03-12T06:27:40.000Z","updated":"2022-08-04T06:52:27.905Z","comments":true,"path":"technology/hexoTutorial.html","link":"","permalink":"https://www.sakura521.cn/technology/hexoTutorial.html","excerpt":"","text":"不说hexo是啥了，毕竟都开始准备搭建了，网上又各种介绍。 前言这个搭建教程是不需要服务器的，因为是搭建到github上的。 当然也可以搭建到服务器，如果感觉不喜欢别人的服务器，推荐使用阿里云的服务器，以前我是搭建到这个上面的，现在搬到了github＋coding双部署。 安装Git以及连接GitHub在你的Windows电脑上安装Git以及连接GitHub,教程见下面的网址。 详细教程 安装Node.js这个是方便Hexo在本地搭建修改的。教程见下面网址。 详细教程 安装Hexo主题来了，来安装Hexo这博客框架。 首先创建一个文件夹，命名为你想要的名字。我的名字叫SakuraHexo，这个文件夹就是用来放博客所有文件的地方。进入文件夹后，按住Shift键同时右键鼠标。 点 在此处打开PowerShell窗口(S) 使用npm命令来安装Hexo npm install -g hexo-cli 安装完成后会有几个报错，这个没关系无视(☆-ｖ-)它就可以了 然后输入 hexo -v 来验证是否安装成功 hexo -v 然后初始化我们的网址，输入 hexo init 接着输入 npm install 来安装这个网址所需要的依赖插件 npm install 完成后，输入hexo g 来生成静态网页 hexo g 结果显示 INFO Generated: INFO Generated: INFO Generated: INFO Generated: INFO * files generated in 1.12 s hexo s 开启本地服务器 hexo s 结果显示 INFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 这就代表启动成功了。 想看网站的样式在浏览器输入网址http://localhost:4000就可以查看了。 如果想关闭本地服务，Ctrl+C 就可以了 或者关闭这个命令窗口。 Hexo常用命令使用最多的几个 hexo new &quot;一个新的文章&quot; #这是创建新的文章的命令 hexo g #生成静态网页 hexo s #启动本地服务 hexo d #部署到github或别地方 其他更详细点的Hexo命令在下面网址看 Hexo常用命令 Hexo美化Hexo有各种各样的主题。本博客使用的hexo-theme-sakura 这个主题的使用教程在下面网址 主题使用教程 主题美化详细教程","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"}],"author":"小坏孩"},{"title":"Hexo接入Google AdSense广告","slug":"Hexo接入Google-AdSense广告","date":"2020-03-12T04:05:33.000Z","updated":"2022-08-04T06:52:27.897Z","comments":true,"path":"technology/AdSense.html","link":"","permalink":"https://www.sakura521.cn/technology/AdSense.html","excerpt":"","text":"注册账号注册账号入口在这里：Google Adsense 注册的时候需要特殊工具，毕竟是谷歌嘛 注册还是很简单的。 添加代码注册完后并添加完个人信息后的样子 获取到广告代码&lt;script data-ad-client=&quot;ca-pub-4531214479514249&quot; async src=&quot;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt; 将代码放到\\themes\\Sakura\\layout_partial\\head.ejs 中 中间即可 例子&lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot; name=&quot;viewport&quot;&gt; &lt;!--谷歌广告--&gt; &lt;script data-ad-client=&quot;ca-pub-4531214479514249&quot; async src=&quot;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; 效果 (adsbygoogle = window.adsbygoogle || []).push({}); 我是sakura的主题，next的主题也一样放到路径。 然后可以先本地运行一下看看F12中有没有这些代码。 然后就可以部署到服务器了。 部署到服务器后 在我已将代码粘贴到自己的网站中 打上对勾 然后点击大功告成。 剩下的等开始填的邮箱通知就可以了","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"}],"author":"小坏孩"},{"title":"Mysql 学习笔记 (二)","slug":"Mysql-学习笔记-二","date":"2020-03-10T07:45:41.000Z","updated":"2022-08-04T06:52:27.900Z","comments":true,"path":"technology/MysqlStudy2.html","link":"","permalink":"https://www.sakura521.cn/technology/MysqlStudy2.html","excerpt":"","text":"Mysql 学习笔记 （一） 的连接https://www.sakura521.cn/2020/02/28/MysqlStudy.html 1、 数据操作-- 增 INSERT [INTO] 表名 [(字段名)] VALUES (值列表)[,(值列表),...] -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。 -- 可同时插入多条数据记录！ REPLACE 与 INSERT 完全一样，可互换。 INSERT [INTO] 表名 SET 字段名=值[,字段名=值,...] -- 查 SELECT 字段列表 FROM 表名 [其他子句] -- 可来自多个表的多个字段 -- 其他子句可以不使用 -- 字段列表可以用*代替，表示所有字段 -- 删 DELETE FROM 表名[删除条件字句] -- 没有条件字句，则会删除全部！！！ -- 改 UPDATE 表名 SET 字段名=新值[,字段名=新值][更新条件] 2、 字符集编码-- MySQL、 数据库、表、字段均可设置编码 -- 数据编码与客户端编码不需一致 SHOW VARIABLES LIKE &#39;character_set_%&#39; -- 查看所有字符集编码项 character_set_client -- 客户端向服务器发送数据时使用的编码 character_set_results -- 服务器端将结果返回给客户端所使用的编码 character_set_connection -- 连接层编码 SET 变量名 = 变量值 set character_set_client = gbk; set character_set_results = gbk; set character_set_connection = gbk; SET NAMES GBK; --相当于完成以上三个设置 -- 校对集 -- 校对集用以排序 SHOW CHARACTER SET [LIKE &#39;pattern&#39;]/SHOW CHARSET [LIKE &#39;pattern&#39;] -- 查看所有字符集 SHOW COLLATION [LIKE &#39;pattern&#39;] -- 查看所有校对集 charset 字符集编码 -- 设置字符集编码 collate 校对集编码 -- 设置校对集编码 3、 数据类型（列类型）数值类型整数-- a. 整型 ---------- 类型 字节 范围（有符号位） tinyint 1字节 -128 ~ 127 无符号位：0 ~ 255 smallint 2字节 -32768 ~ 32767 mediumint 3字节 -8388608 ~ 8388607 int 4字节 bigint 8字节 int(M) M表示总位数 -- 默认存在符号位，unsigned 属性修改 -- 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改 -- 例：int(5) 插入一个数&#39;123&#39;，补填后为&#39;00123&#39; -- 在满足要求的情况下，越小越好。 -- 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。 浮点型-- b. 浮点型 ---------- 类型 字节 范围 float(单精度) 4字节 double(双精度) 8字节 -- 浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。 -- 不同于整型，前后均会补填0. -- 定义浮点型时，需指定总位数和小数位数。 float(M, D) double(M, D) -- M表示总位数，D表示小数位数。 -- M和D的大小会决定浮点数的范围。不同于整型的固定范围。 -- M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。 -- 支持科学计数法表示。 -- 浮点数表示近似值。 定点数-- c. 定点数 ---------- decimal -- 可变长度 decimal(M, D) -- M也表示总位数，D表示小数位数。 -- 保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。 -- 将浮点数转换为字符串来保存，每9位数字保存为4个字节。 字符串类型char,varchar-- a. char, varchar ---------- char -- 定长字符串，速度快，但浪费空间 varchar -- 变长字符串，速度慢，但节省空间 -- M表示能存储的最大长度，此长度是字符数，非字节数。 -- 不同的编码，所占用的空间不同。 char,最多255个字符，与编码无关。 varchar,最多65535字符，与编码有关。 -- 一条有效记录最大不能超过65535个字节。 -- utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符 varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。 varchar 的最大有效长度由最大行大小和使用的字符集确定。 -- 最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。 例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3 blob,text-- b. blob, text ---------- blob 二进制字符串（字节字符串） tinyblob, blob, mediumblob, longblob text 非二进制字符串（字符字符串） tinytext, text, mediumtext, longtext text 在定义时，不需要定义长度，也不会计算总长度。 text 类型在定义时，不可给default值 binary,varbinary-- c. binary, varbinary ---------- -- 类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。 char, varchar, text 对应 binary, varbinary, blob. (adsbygoogle = window.adsbygoogle || []).push({}); 日期时间类型-- 一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。 datetime 8字节 日期及时间 1000-01-01 00:00:00 到 9999-12-31 23:59:59 date 3字节 日期 1000-01-01 到 9999-12-31 timestamp 4字节 时间戳 19700101000000 到 2038-01-19 03:14:07 time 3字节 时间 -838:59:59 到 838:59:59 year 1字节 年份 1901 - 2155 datetime “YYYY-MM-DD hh:mm:ss” timestamp “YY-MM-DD hh:mm:ss” “YYYYMMDDhhmmss” “YYMMDDhhmmss” YYYYMMDDhhmmss YYMMDDhhmmss date “YYYY-MM-DD” “YY-MM-DD” “YYYYMMDD” “YYMMDD” YYYYMMDD YYMMDD time “hh:mm:ss” “hhmmss” hhmmss year “YYYY” “YY” YYYY YY 枚举和集合-- 枚举(enum) ---------- enum(val1, val2, val3...) 在已知的值中进行单选。最大数量为65535. 枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。 表现为字符串类型，存储却是整型。 NULL值的索引是NULL。 空字符串错误值的索引值是0。 -- 集合（set） ---------- set(val1, val2, val3...) create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) ); insert into tab values (&#39;男, 女&#39;); 最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。 当创建表时，SET成员值的尾部空格将自动被删除。 4、 选择类型-- PHP角度 1. 功能满足 2. 存储空间尽量小，处理效率更高 3. 考虑兼容问题 -- IP存储 ---------- 1. 只需存储，可用字符串 2. 如果需计算，查找等，可存储为4个字节的无符号int，即unsigned 1) PHP函数转换 ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。 利用sprintf函数格式化字符串 sprintf(&quot;%u&quot;, ip2long(&#39;192.168.3.134&#39;)); 然后用long2ip将整型转回IP字符串 2) MySQL函数转换(无符号整型，UNSIGNED) INET_ATON(&#39;127.0.0.1&#39;) 将IP转为整型 INET_NTOA(2130706433) 将整型转为IP 5、 列属性（列约束） -- 能唯一标识记录的字段，可以作为主键。 -- 一个表只能有一个主键。 -- 主键具有唯一性。 -- 声明字段时，用 primary key 标识。 也可以在字段列表之后声明 例：create table tab ( id int, stu varchar(10), primary key (id)); -- 主键字段的值不能为null。 -- 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。 例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age)); 2. unique 唯一索引（唯一约束） 使得某字段的值也不能重复。 3. null 约束 null不是数据类型，是列的一个属性。 表示当前列是否可以为null，表示什么都没有。 null, 允许为空。默认。 not null, 不允许为空。 insert into tab values (null, &#39;val&#39;); -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null 4. default 默认值属性 当前字段的默认值。 insert into tab values (default, &#39;val&#39;); -- 此时表示强制使用默认值。 create table tab ( add_time timestamp default current_timestamp ); -- 表示将当前时间的时间戳设为默认值。 current_date, current_time 5. auto_increment 自动增长约束 自动增长必须为索引（主键或unique） 只能存在一个字段为自动增长。 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x; 6. comment 注释 例：create table tab ( id int ) comment &#39;注释内容&#39;; 7. foreign key 外键约束 用于限制主表与从表数据完整性。 alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id); -- 将表t1的t1_id外键关联到表t2的id字段。 -- 每个外键都有一个名字，可以通过 constraint 指定 存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。 作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。 MySQL中，可以对InnoDB引擎使用外键约束： 语法： foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作] 此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。 可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。 如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择： 1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。 2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。 3. restrict，拒绝父表删除和更新。 注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。 6、 建表规范/* 建表规范 */ ------------------ -- Normal Format, NF - 每个表保存一个实体信息 - 每个具有一个ID字段作为主键 - ID主键 + 原子表 -- 1NF, 第一范式 字段不能再分，就满足第一范式。 -- 2NF, 第二范式 满足第一范式的前提下，不能出现部分依赖。 消除符合主键就可以避免部分依赖。增加单列关键字。 -- 3NF, 第三范式 满足第二范式的前提下，不能出现传递依赖。 某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。 将一个实体信息的数据放在一个表内实现。 7、 select/* select */ ------------------ select [all|distinct] select_expr from -&gt; where -&gt; group by [合计函数] -&gt; having -&gt; order by -&gt; limit a. select_expr -- 可以用 * 表示所有字段。 select * from tb; -- 可以使用表达式（计算公式、函数调用、字段也是个表达式） select stu, 29+25, now() from tb; -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。 - 使用 as 关键字，也可省略 as. select stu+10 as add10 from tb; b. from 子句 用于标识查询来源。 -- 可以为表起别名。使用as关键字。 select * from tb1 as tt, tb2 as bb; -- from子句后，可以同时出现多个表。 -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。 select * from tb1, tb2; c. where 子句 -- 从from获得的数据源中进行筛选。 -- 整型1表示真，0表示假。 -- 表达式由运算符和运算数组成。 -- 运算数：变量（字段）、值、函数返回值 -- 运算符： =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||, in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor is/is not 加上ture/false/unknown，检验某个值的真假 &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较 d. group by 子句, 分组子句 group by 字段/别名 [排序方式] 分组后会进行排序。升序：ASC，降序：DESC 以下[合计函数]需配合 group by 使用： count 返回不同的非NULL值数目 count(*)、count(字段) sum 求和 max 求最大值 min 求最小值 avg 求平均值 group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。 e. having 子句，条件子句 与 where 功能、用法相同，执行时机不同。 where 在开始时执行检测数据，对原数据进行过滤。 having 对筛选出的结果再次进行过滤。 having 字段必须是查询出来的，where 字段必须是数据表存在的。 where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。 where 不可以使用合计函数。一般需用合计函数才会用 having SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。 f. order by 子句，排序子句 order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]... 升序：ASC，降序：DESC 支持多个字段的排序。 g. limit 子句，限制结果数量子句 仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。 limit 起始位置, 获取条数 省略第一个参数，表示从索引0开始。limit 获取条数 h. distinct, all 选项 distinct 去除重复记录 默认为 all, 全部记录 8、 insert/* insert */ ------------------ select语句获得的数据可以用insert插入。 可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。 或者使用set语法。 insert into tbl_name set field=value,...； 可以一次性使用多个值，采用(), (), ();的形式。 insert into tbl_name values (), (), (); 可以在列值指定时，使用表达式。 insert into tbl_name values (field_value, 10+10, now()); 可以使用一个特殊值 default，表示该列使用默认值。 insert into tbl_name values (field_value, default); 可以通过一个查询的结果，作为需要插入的值。 insert into tbl_name select ...; 可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。 insert into tbl_name values/set/select on duplicate key update 字段=值, …; 9、 deleteDELETE FROM tbl_name [WHERE where_definition] [ORDER BY ...] [LIMIT row_count] 按照条件删除 指定删除的最多记录数。Limit 可以通过排序条件删除。order by + limit 支持多表删除，使用类似连接语法。 delete from 需要删除数据多表1，表2 using 表连接操作 条件。 (adsbygoogle = window.adsbygoogle || []).push({}); 10、 UNION/* UNION */ ------------------ 将多个select查询的结果组合成一个结果集合。 SELECT ... UNION [ALL|DISTINCT] SELECT ... 默认 DISTINCT 方式，即所有返回的行都是唯一的 建议，对每个SELECT查询加上小括号包裹。 ORDER BY 排序时，需加上 LIMIT 进行结合。 需要各select查询的字段数量一样。 每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。 11、 子查询/* 子查询 */ ------------------ - 子查询需用括号包裹。 -- from型 from后要求是一个表，必须给子查询结果取个别名。 - 简化每个查询内的条件。 - from型需将结果生成一个临时表格，可用以原表的锁定的释放。 - 子查询返回一个表，表型子查询。 select * from (select * from tb where id&gt;0) as subfrom where id&gt;1; -- where型 - 子查询返回一个值，标量子查询。 - 不需要给子查询取别名。 - where子查询内的表，不能直接用以更新。 select * from tb where money = (select max(money) from tb); -- 列子查询 如果子查询结果返回的是一列。 使用 in 或 not in 完成查询 exists 和 not exists 条件 如果子查询返回数据，则返回1或0。常用于判断条件。 select column1 from t1 where exists (select * from t2); -- 行子查询 查询条件是一个行。 select * from t1 where (id, gender) in (select id, gender from t2); 行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...) 行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。 -- 特殊运算符 != all() 相当于 not in = some() 相当于 in。any 是 some 的别名 != some() 不等同于 not in，不等于其中某一个。 all, some 可以配合其他运算符一起使用。 12、 连接查询/* 连接查询(join) */ ------------------ 将多个表的字段进行连接，可以指定连接条件。 -- 内连接(inner join) - 默认就是内连接，可省略inner。 - 只有数据存在时才能发送连接。即连接结果不能出现空行。 on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真） 也可用where表示连接条件。 还有 using, 但需字段名相同。 using(字段名) -- 交叉连接 cross join 即，没有条件的内连接。 select * from tb1 cross join tb2; -- 外连接(outer join) - 如果数据不存在，也会出现在连接结果中。 -- 左外连接 left join 如果数据不存在，左表记录会出现，而右表为null填充 -- 右外连接 right join 如果数据不存在，右表记录会出现，而左表为null填充 -- 自然连接(natural join) 自动判断连接条件完成连接。 相当于省略了using，会自动查找相同字段名。 natural join natural left join natural right join select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id; 13、 导入导出/* 导入导出 */ ------------------ select * into outfile 文件地址 [控制格式] from 表名; -- 导出表数据 load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; -- 导入数据 生成的数据默认的分隔符是制表符 local未指定，则数据文件必须在服务器上 replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理 -- 控制格式 fields 控制字段格式 默认：fields terminated by &#39;\\t&#39; enclosed by &#39;&#39; escaped by &#39;\\\\&#39; terminated by &#39;string&#39; -- 终止 enclosed by &#39;char&#39; -- 包裹 escaped by &#39;char&#39; -- 转义 -- 示例： SELECT a,b,a+b INTO OUTFILE &#39;/tmp/result.text&#39; FIELDS TERMINATED BY &#39;,&#39; OPTIONALLY ENCLOSED BY &#39;&quot;&#39; LINES TERMINATED BY &#39;\\n&#39; FROM test_table; lines 控制行格式 默认：lines terminated by &#39;\\n&#39; terminated by &#39;string&#39; -- 终止 14、 truncate/* truncate */ ------------------ TRUNCATE [TABLE] tbl_name 清空数据 删除重建表 区别： 1，truncate 是删除表再创建，delete 是逐条删除 2，truncate 重置auto_increment的值。而delete不会 3，truncate 不知道删除了几条，而delete知道。 4，当被用于带分区的表时，truncate 会保留分区 (adsbygoogle = window.adsbygoogle || []).push({}); 15、 备份与还原备份，将数据的结构与表内数据保存起来。 利用 mysqldump 指令完成。 -- 导出 1. 导出一张表 mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql) 2. 导出多张表 mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql) 3. 导出所有表 mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql) 4. 导出一个库 mysqldump -u用户名 -p密码 -B 库名 &gt; 文件名(D:/a.sql) 可以-w携带备份条件 -- 导入 1. 在登录mysql的情况下： source 备份文件 2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件 16、 视图 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。 视图具有表结构文件，但不存在数据文件。 对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。 视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。 -- 创建视图 CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] VIEW view_name [(column_list)] AS select_statement - 视图名必须唯一，同时不能与表重名。 - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。 - 可以指定视图执行的算法，通过ALGORITHM指定。 - column_list如果存在，则数目必须等于SELECT语句检索的列数 -- 查看结构 SHOW CREATE VIEW view_name -- 删除视图 - 删除视图后，数据依然存在。 - 可同时删除多个视图。 DROP VIEW [IF EXISTS] view_name ... -- 修改视图结构 - 一般不修改视图，因为不是所有的更新视图都会映射到表上。 ALTER VIEW view_name [(column_list)] AS select_statement -- 视图作用 1. 简化业务逻辑 2. 对客户端隐藏真实的表结构 -- 视图算法(ALGORITHM) MERGE 合并 将视图的查询语句，与外部查询需要先合并再执行！ TEMPTABLE 临时表 将视图执行完毕后，形成临时表，再做外层查询！ UNDEFINED 未定义(默认)，指的是MySQL自主去选择相应的算法。 未完 转载原地址知乎： 老夫整理的1000行MySQL学习笔记传授有缘人","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"java","slug":"java","permalink":"https://www.sakura521.cn/tags/java/"}],"author":"小坏孩"},{"title":"B站作品【派大星的独白】一个关于正常人的故事 ","slug":"B站作品【派大星的独白】一个关于正常人的故事","date":"2020-03-10T01:40:05.000Z","updated":"2022-08-04T06:52:27.893Z","comments":true,"path":"recreation/PatrickStar.html","link":"","permalink":"https://www.sakura521.cn/recreation/PatrickStar.html","excerpt":"","text":"这是我在B站发现的一个很好的视频。 Up主：洛温阿特金森 原视频地址： https://www.bilibili.com/video/av60731116 本视频用B站的嵌入代码，所以观看量也是增加到原作者视频上。 &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=60731116&amp;cid=106015992&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;width: 640px; height: 430px; max-width: 100%&quot; &gt; &lt;/iframe&gt;","categories":[{"name":"娱乐","slug":"娱乐","permalink":"https://www.sakura521.cn/categories/%E5%A8%B1%E4%B9%90/"}],"tags":[{"name":"娱乐","slug":"娱乐","permalink":"https://www.sakura521.cn/tags/%E5%A8%B1%E4%B9%90/"},{"name":"B站","slug":"B站","permalink":"https://www.sakura521.cn/tags/B%E7%AB%99/"}],"author":"小坏孩"},{"title":"SpringBoot 使用jackson处理json数据 学习笔记","slug":"SpringBoot-使用jackson处理json数据-学习笔记","date":"2020-03-04T06:37:40.000Z","updated":"2022-08-04T06:52:27.904Z","comments":true,"path":"technology/jackson.html","link":"","permalink":"https://www.sakura521.cn/technology/jackson.html","excerpt":"","text":"Json已经成为当前服务器与 WEB 应用之间数据传输的公认标准。目前java json解析工具有阿里的fastjson，google的GSON，以及SpringMVC 默认的解析工具Jackson。SpringBoot默认自带是jackson,网上有很多json转换速率的比对,如jackson,阿里的fastjson等,不过jackson足够使用了. 1、 在pom.xml引依赖&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.5&lt;/version&gt; &lt;/dependency&gt; 一般情况下,SpringBoot开发web应用会引用spring-boot-starter-web依赖包,而这个依赖包会默认引用 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;/dependency&gt; Jackson 主要有三部分组成，除了三个模块之间存在依赖，不依赖任何外部 jar 包。三个模块的 作用及 artifactId 如下： jackson-core: 核心包 jackson-annotations:注解包 jackson-databind:数据绑定（依赖 core 和 annotations ） 而 jackson-databind 依赖另外两个,所以单独引用时,只引用 jackson-databind 就可以使用了. 2、 使用实体类：package cn.sakura521.jacksondemo.entity; import com.fasterxml.jackson.annotation.JsonFormat; import java.util.Date; public class User &#123; private String name; //不JSON序列化加 @JsonIgnore // @JsonIgnore private Integer age; //格式化日期属性 @JsonFormat(pattern = &quot;yyyy年MM月dd日&quot;) private Date date; private String url; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, age=&quot; + age + &quot;, date=&quot; + date + &quot;, url=&#39;&quot; + url + &#39;\\&#39;&#39; + &#39;&#125;&#39;; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Date getDate() &#123; return date; &#125; public void setDate(Date date) &#123; this.date = date; &#125; &#125; 序列化ObjectMapper是JSON操作的核心，Jackson的所有JSON操作都是在ObjectMapper中实现。 ObjectMapper有多个JSON序列化的方法，可以把JSON字符串保存File、OutputStream等不同的介质中。 writeValue(File arg0, Object arg1)把arg1转成json序列，并保存到arg0文件中。 writeValue(OutputStream arg0, Object arg1)把arg1转成json序列，并保存到arg0输出流中。 writeValueAsBytes(Object arg0)把arg0转成json序列，并把结果输出成字节数组。 writeValueAsString(Object arg0)把arg0转成json序列，并把结果输出成字符串。 (adsbygoogle = window.adsbygoogle || []).push({}); 示例：package cn.sakura521.jacksondemo; import cn.sakura521.jacksondemo.entity.User; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.IOException; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; import java.util.List; public class jacksonDemo &#123; public static void main(String[] args) throws ParseException, IOException &#123; User user = new User(); user.setName(&quot;小坏孩&quot;); user.setAge(21); user.setUrl(&quot;https://www.sakura521.cn&quot;); //当前时间 Date date = new Date(); user.setDate(date); // SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); // user.setDate(dateFormat.parse(&quot;2020-03-04&quot;)); ObjectMapper mapper = new ObjectMapper(); //类转JSON //输出结果是：&#123;&quot;name&quot;:&quot;小坏孩&quot;,&quot;age&quot;:21,&quot;date&quot;:1583251200000,&quot;url&quot;:&quot;www.sakura521.cn&quot;&#125; //User类Date加上（格式化日期属性）@JsonFormat(pattern = &quot;yyyy年MM月dd日&quot;)后 //结果为：&#123;&quot;name&quot;:&quot;小坏孩&quot;,&quot;age&quot;:21,&quot;date&quot;:&quot;2020年03月04日&quot;,&quot;url&quot;:&quot;www.sakura521.cn&quot;&#125; String json = mapper.writeValueAsString(user); System.out.println(json); //集合转JSON //输出结果是：[&#123;&quot;name&quot;:&quot;小坏孩&quot;,&quot;age&quot;:21,&quot;date&quot;:1583251200000,&quot;url&quot;:&quot;www.sakura521.cn&quot;&#125;] //User类Date加上（格式化日期属性）@JsonFormat(pattern = &quot;yyyy年MM月dd日&quot;)后 //结果为：[&#123;&quot;name&quot;:&quot;小坏孩&quot;,&quot;age&quot;:21,&quot;date&quot;:&quot;2020年03月04日&quot;,&quot;url&quot;:&quot;www.sakura521.cn&quot;&#125;] List&lt;User&gt; users = new ArrayList&lt;&gt;(); users.add(user); String jsonlist = mapper.writeValueAsString(users); System.out.println(jsonlist); &#125; &#125; 反序列化package cn.sakura521.jacksondemo; import cn.sakura521.jacksondemo.entity.User; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.IOException; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Date; import java.util.List; public class jacksonDemo &#123; public static void main(String[] args) throws ParseException, IOException &#123; String json1 = &quot;&#123;\\&quot;name\\&quot;:\\&quot;小坏孩\\&quot;,\\&quot;age\\&quot;:21,\\&quot;date\\&quot;:1583251200000,\\&quot;url\\&quot;:\\&quot;www.sakura521.cn\\&quot;&#125;&quot;; /** * ObjectMapper支持从byte[]、File、InputStream、字符串等数据的JSON反序列化。 */ //输出结果：User&#123;name=&#39;小坏孩&#39;, age=21, date=Wed Mar 04 00:00:00 CST 2020, url=&#39;www.sakura521.cn&#39;&#125; User user1 = mapper.readValue(json1,User.class); System.out.println(user1); &#125; &#125; JSON注释Jackson提供了一系列注解，方便对JSON序列化和反序列化进行控制，下面介绍一些常用的注解。 @JsonIgnore 此注解用于属性上，作用是进行JSON操作时忽略该属性。 @JsonFormat 此注解用于属性上，作用是把Date类型直接转化为想要的格式，如@JsonFormat(pattern = &quot;yyyy-MM-dd HH-mm-ss&quot;)。 @JsonProperty 此注解用于属性上，作用是把该属性的名称序列化为另外一个名称，如把trueName属性序列化为name，@JsonProperty(&quot;name&quot;)。 示例： private String name; //不JSON序列化加 @JsonIgnore // @JsonIgnore private Integer age; //格式化日期属性 @JsonFormat(pattern = &quot;yyyy年MM月dd日&quot;) private Date date; private String url; readTree在jackson中，有些场景下，在实现一些基础服务和拦截器的时候，我们可能需要在不知道JSON字符串所属对象类型的情况下，对JSON字符串中的某些属性进行遍历和修改，比如，设置或查询一些报文头字段。 在jackson中，使用最多的jsonNode抽象类并没有提供修改节点值的方法，而是在ObjectNode节点中提供修改接口，这个节点在官方说明中，一般用户创建新的节点。 在ObjectNode节点中提供修改接口（put）,JsonNode提供查询的接口： JsonNode rootNode = mapper.readTree(jsonStr);//jsonStr是一个json字符串 JsonNode targetNode = null; targetNode = rootNode.findValue(&quot;rpcMsgId&quot;); // 查找第一级的rpcMsgId属性,如果属性不存在,则返回null,属性值如果为明确的null，返回NullNode，否则返回正常的JsonNode // 注：JsonNode还提供了find/path/get等获取节点的方法，但是这三种方法都不能明确的区分节点不存在、为明确的null。所以，应该使用findValue方法。 如果只是纯粹的遍历和类似JsonTree的构造，网上有各种文章，主要是对原json中属性的修改。可通过如下的方式进行修改： ((ObjectNode)targetNode).put(&quot;rpcMsgId&quot;,&quot;abcdefg1234567890&quot;); // 通过强制转换为ObjectNode，就可以对当前节点进行修改,其他的XXXNode均没有提供相关的API接口 String modifiedJsonStr = mapper.writeValueAsString(rootNode); // 最后重新生成json字符串，这跟dom4j修改xml一样，只能重新生成，内置不支持直接修改原文件 //完整的代码 JsonNode node = mapper.readTree(jsonStr); JsonNode node1 = node.findValue(&quot;spiderPacketHead&quot;); ObjectNode node2 = (ObjectNode) node1; node2.put(&quot;rpcMsgId&quot;, &quot;abc&quot;); (adsbygoogle = window.adsbygoogle || []).push({}); 修改后的工具类JsonUtilsimport java.util.List; import java.util.Map; import com.fasterxml.jackson.core.JsonParser.Feature; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.DeserializationFeature; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature; /** * &lt;b&gt;Description:&lt;/b&gt; json转换工具类 &lt;br&gt; * * @author luozhen * @version 1.0 * @Note &lt;b&gt;ProjectName:&lt;/b&gt; MySpringBoot &lt;br&gt; * &lt;b&gt;PackageName:&lt;/b&gt; com.luozhen.util &lt;br&gt; * &lt;b&gt;ClassName:&lt;/b&gt; JacksonActivity &lt;br&gt; * &lt;b&gt;Date:&lt;/b&gt; 2018年5月24日 下午12:50:59 */ public class JsonUtils &#123; /** * ObjectMapper是JSON操作的核心，Jackson的所有JSON操作都是在ObjectMapper中实现。 * ObjectMapper有多个JSON序列化的方法，可以把JSON字符串保存File、OutputStream等不同的介质中。 * writeValue(File arg0, Object arg1)把arg1转成json序列，并保存到arg0文件中。 * writeValue(OutputStream arg0, Object arg1)把arg1转成json序列，并保存到arg0输出流中。 * writeValueAsBytes(Object arg0)把arg0转成json序列，并把结果输出成字节数组。 * writeValueAsString(Object arg0)把arg0转成json序列，并把结果输出成字符串。 */ /** * 初始化变量 */ private static ObjectMapper mapper = new ObjectMapper(); static &#123; // 解决实体未包含字段反序列化时抛出异常 mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); // 对于空的对象转json的时候不抛出错误 mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS); // 允许属性名称没有引号 mapper.configure(Feature.ALLOW_UNQUOTED_FIELD_NAMES, true); // 允许单引号 mapper.configure(Feature.ALLOW_SINGLE_QUOTES, true); &#125; /** * * &lt;b&gt;Description:&lt;/b&gt; 将一个object转换为json, 可以使一个java对象，也可以使集合&lt;br&gt; * &lt;b&gt;Title:&lt;/b&gt; ObjectToJson&lt;br&gt; * * @param obj * - 传入的数据 * @return * @Note &lt;b&gt;Author:&lt;/b&gt; luozhen &lt;br&gt; * &lt;b&gt;Date:&lt;/b&gt; 2018年5月24日 下午1:26:53 &lt;br&gt; * &lt;b&gt;Version:&lt;/b&gt; 1.0 */ public static String objectToJson(Object obj) &#123; String json = null; try &#123; json = mapper.writeValueAsString(obj); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return json; &#125; /** * ObjectMapper支持从byte[]、File、InputStream、字符串等数据的JSON反序列化。 */ /** * * &lt;b&gt;Description:&lt;/b&gt; 将json结果集转化为对象&lt;br&gt; * &lt;b&gt;Title:&lt;/b&gt; jsonToClass&lt;br&gt; * * @param json * - json数据 * @param beanType * - 转换的实体类型 * @return * @Note &lt;b&gt;Author:&lt;/b&gt; luozhen &lt;br&gt; * &lt;b&gt;Date:&lt;/b&gt; 2018年5月24日 下午3:26:18 &lt;br&gt; * &lt;b&gt;Version:&lt;/b&gt; 1.0 */ public static &lt;T&gt; T jsonToClass(String json, Class&lt;T&gt; beanType) &#123; T t = null; try &#123; t = mapper.readValue(json, beanType); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return t; &#125; /** * * &lt;b&gt;Description:&lt;/b&gt; 将json数据转换成Map&lt;br&gt; * &lt;b&gt;Title:&lt;/b&gt; jsonToMap&lt;br&gt; * * @param json * - 转换的数据 * @return * @Note &lt;b&gt;Author:&lt;/b&gt; luozhen &lt;br&gt; * &lt;b&gt;Date:&lt;/b&gt; 2018年5月24日 下午3:29:37 &lt;br&gt; * &lt;b&gt;Version:&lt;/b&gt; 1.0 */ public static Map&lt;String, Object&gt; jsonToMap(String json) &#123; Map&lt;String, Object&gt; map = null; try &#123; map = mapper.readValue(json, new TypeReference&lt;Map&lt;String, Object&gt;&gt;() &#123;&#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return map; &#125; /** * * &lt;b&gt;Description:&lt;/b&gt; 将json数据转换成list &lt;br&gt; * &lt;b&gt;Title:&lt;/b&gt; jsonToList&lt;br&gt; * * @param json * - 转换的数据 * @return * @Note &lt;b&gt;Author:&lt;/b&gt; luozhen &lt;br&gt; * &lt;b&gt;Date:&lt;/b&gt; 2018年5月24日 下午3:28:35 &lt;br&gt; * &lt;b&gt;Version:&lt;/b&gt; 1.0 */ public static &lt;T&gt; List&lt;T&gt; jsonToList(String json, Class&lt;T&gt; beanType) &#123; List&lt;T&gt; list = null; try &#123; JavaType javaType = mapper.getTypeFactory().constructParametricType(List.class, beanType); list = mapper.readValue(json, javaType); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return list; &#125; /** * * &lt;b&gt;Description:&lt;/b&gt; 获取json对象数据的属性&lt;br&gt; * &lt;b&gt;Title:&lt;/b&gt; findValue&lt;br&gt; * * @param resData * - 请求的数据 * @param resPro * - 请求的属性 * @return 返回String类型数据 * @Note &lt;b&gt;Author:&lt;/b&gt; luozhen &lt;br&gt; * &lt;b&gt;Date:&lt;/b&gt; 2018年5月31日 上午10:00:09 &lt;br&gt; * &lt;b&gt;Version:&lt;/b&gt; 1.0 */ public static String findValue(String resData, String resPro) &#123; String result = null; try &#123; JsonNode node = mapper.readTree(resData); JsonNode resProNode = node.get(resPro); result = JsonUtils.objectToJson(resProNode); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; &#125; 引用地址：作者：渊默十三链接：https://www.jianshu.com/p/b804874b7a69来源：简书","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"java","slug":"java","permalink":"https://www.sakura521.cn/tags/java/"}],"author":"小坏孩"},{"title":"免费CDN：jsDeliver+Github 搭建过程记录","slug":"免费CDN：jsDeliver-Github-搭建过程记录","date":"2020-03-02T02:30:30.000Z","updated":"2022-08-04T06:52:27.909Z","comments":true,"path":"technology/freeCDN.html","link":"","permalink":"https://www.sakura521.cn/technology/freeCDN.html","excerpt":"","text":"CDN 维基百科解释内容分发网络（英语：Content Delivery Network或Content Distribution Network，缩写：CDN）是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。 1、 首先创建一个Github仓库 我的仓库名为CDN并不是图中的CDNNAME，因为我已经创建了名字为CDN的仓库，不能创建重复的。 2、 克隆Github仓库到本地先在本地创建一个文件夹，任意位置都可以（最好不要在C盘），然后进入到文件夹中。 然后再去Github仓库，复制仓库的ssh地址。 在本地目录中右键Git Bash Here,在命令窗口中执行一下命令： git clone 复制的仓库ssh地址 3、 上传文件到Github仓库将你要上传的图片视频保存到刚才那个本地文件夹中（上传的单个文件不要大于50M），然后在文件夹中右键Git Bash Here,执行一下命令： git status //查看状态 git add . //添加所有文件到暂存区 不要忘记后面那个. git commit -m &#39;提交信息&#39; //把文件提交到仓库 git push //推送至远程仓库 4、 发布版本 然后自定义一个发布版本号 到现在就可以使用了。 (adsbygoogle = window.adsbygoogle || []).push({}); 5、 更新版本方法一可以跟上面3、4步骤一样去更新它。 方法二还有更简便的，前提是已经安装了TortoiseGit.如果没有直接跳过此方法。 1、 首先右键 Git提交 提交右边有个向下的小箭头，可以点选提交并推送。直接完事，然后去github上创建新的版本就可以了。 成功后点击推送。 这就提交到了Github 接下来就是进行第四步的创建版本了。 6、 使用方法文件网址位置：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 @发布的版本号 可以不写，默认就是最新版本。 https://cdn.jsdelivr.net/gh/wang1375830242/CDN@1.02/images/Konachan.com-ls-black_hair-f-toriki-touhou.jpg https://cdn.jsdelivr.net/gh/wang1375830242/CDN/images/Konachan.com-ls-black_hair-f-toriki-touhou.jpg 第一个是代版本号的，第二个不带版本号。两个都是一样的图片。 7、 更加具体的方法官网查看https://www.jsdelivr.com/ 8、 更方便的一种方式2020.3.13更新的新方法 使用 PicGo+jsDelivr+GitHub搭建免费cdn加速图床","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"}],"author":"小坏孩"},{"title":"RSS 介绍","slug":"RSS-介绍","date":"2020-02-28T12:56:45.000Z","updated":"2022-08-04T06:52:27.902Z","comments":true,"path":"technology/RSSExplanation.html","link":"","permalink":"https://www.sakura521.cn/technology/RSSExplanation.html","excerpt":"","text":"RSS​ RSS（简易信息聚合）是一种消息来源格式规范，用以聚合经常发布更新数据的网站，例如博客文章、新闻、音频或视频的网摘。RSS文件（或称做摘要、网络摘要、或频更新，提供到频道）包含全文或是节录的文字，再加上发布者所订阅之网摘数据和授权的元数据。 ​ “资源描述框架站点摘要”（RDF Site Summary）就是RSS的英文原意，后来通过逆向首字母缩略词变更为Really Simple Syndication“简易信息聚合”。把新闻标题、摘要（Feed）、内容按照用户的要求，“送”到用户的桌面就是RSS的目的。RSS一词有时候大体上意为社会性书签，包括各种RSS的不同格式。例如，Blogspace对使用网摘于一集成器内之动作标为RSS info和RSS reader。虽然它的第一个句子就包含明确的Atom格式：“RSS和Atom文件能够用简单的格式从网站更新消息至你的电脑！” ​ RSS摘要可以借由RSS阅读器、feed reader或是aggregator等网页或以桌面为架构的软件来阅读。标准的XML档式可允许信息在一次发布后透过不同的程序阅览。用户借由将网摘输入RSS阅读器或是用鼠标点取浏览器上指向订阅程序的RSS小图标之URI（非通常称为URL）来订阅网摘。RSS阅读器定期检阅是否有更新，然后下载给监看用户界面。 RSS可以是以下三种解释中任一种的缩写，但其实这三者都是指同一种联合供稿（Syndication）的技术： RSS 2.0（Really Simple Syndication） RSS 0.91, RSS 1.0（**RDF（Resource Description Framework）Site Summary**） RSS 0.9 and 1.0（Rich Site Summary） 目录版本当前RSS规范的主要版本有0.91、1.0和2.0等。0.91版和1.0版完全不同，风格不同，制定标准的人也不同。0.91版和2.0版一脉相承。1.0版更接近XML标准。当前世界上大多数知名，虽有很多种不同的RSS，但都定型于两个重要的支干（RDF和2.*）。RDF或RSS 1.*的分支包括下列版本： RSS 0.90原本属于美国网景公司的版本。这个RSS被称为*RDF Site Summary*，但其基础构图创建在初期的RDF规格上，以及和末版的RDF推荐标准不兼容。 RSS 1.0是一个开放式的版本，由RSS-DEV工作团队再次创建为RDF Site Summary。RSS 1.0是一个像RSS 0.90的RDF形式，但是并没有完全的和他兼容，自从1.0基新闻网站都提供RSS订阅支持。 历史RSS格式采纳之前有过几次web联合化的尝试，但都没有达到广泛的传播。关于重构web站点信息的基本思想可以追溯到早至1995年，当时Ramanathan V. Guha{以及他在苹果公司高科技小组的同事开发出元内容框架。对这些早期发展的更详细讨论，请参见网页联合供稿技术的历史。 RSS的第一个版本为RDF Site Summary，在1999年三月由美国网景公司的Guha为了用在My.Netscape.Com门户网站而开发。这个版本开始以RSS0.9为名。在1999年七月，美国网景公司的Dan Libby发明了新版本RSS 0.91，此版本简化了形式，借由 撤去RDF元素及合并Dave Winer的scriptingNews企业联合组织化格式。Libby并且将此重命名为RSS，全名“Rich Site Summary”，并且在“Futures document”论述了未来的发展形式。 这会是Netscape在RSS八年的研究中最后一次的参与，当RSS被一些想要他们的feeds被用在My.Netscape.Com和其他早期RSS入口的网络出版者环绕，美国“网景”公司下降RSS并支持MY. Netscape.Com在2001年四月期间新主人AOL的重建公司，还取消了支撑格式化的使用帮助文档和工具。 其中，Google Reader曾集成了RSS的分类与自定义标题，网页功能。但于2013年7月15日已终止服务。 发展随着越来越多的站点对RSS的支持，RSS当前已经成为成功的XML应用。RSS搭建了信息迅速传播的一个技术平台，使得每个人都成为潜在的信息提供者。 RSS 2.*的分支包括下列版本： RSS 0.91是一个精简的RSS形式，由美国网景公司所发行，同时也是原创的排行第一的版本编号，由Dave Winer从Userland软件所制作。网景公司的版本现在被称为Rich Site Summary； 这个是不久前的RDF格式，但是相对而言比较不方便使用。 RSS 0.92透过0.94被扩大为RSS 0.91版本，更容易与其他兼容以及和Winer的RSS 0.91版本，但仍然和RSS 0.90不兼容。在所有的Userland RSS 0.9x规格里，RSS不再只是个缩写。 RSS 2.0.1是国内版本编号2.0。RSS 2.0.1虽被声称冻结，但是仍是一个网页然可以快速下载，之后再声称没有改变版本编号。RSS现今代表着简易供稿系统。主要的改变在这个版本里使用伸的机制。 对大部分而言，和较早的版本比较起来（除了无兼容性的RDF语法在0.90），较新的版本接触到各个分支时为逆兼容性，以及大部分的版本严格上来说包括以延伸机构使用XML Namespaces来证明，另一方面正好（在2.* 分支）或透过RDF（在1.* 分支），大部分的企业联合组织化软件都有支持这两种分支。 模块RSS模块的主要目标是延伸基本的XML概要来获得更健全的内容汇集。此种传承允许更多的变化却又能够符合标准，在不用更改RSS核心之下运行。为了达成此项延伸，严密规范的字汇（在RSS中为“模块”；XML中为“概要”）透过XML namesspace命名各种概念之中的概念。 点对点应用及RSS几种以BitTorrent为基准和点对点的应用也支持RSS。此种网摘允许客户端的应用程序在侦测到更新时自动下载。 阅读器主条目：聚合器 RSS信息的获取与订阅，可以通过称为聚合器一类的软件或服务来实现。通常情况下RSS阅读器除了客户端软件之外，还存在一类基于Web应用的在线阅读器（例如digg.com）。较常用的有预载于Acer个人电脑当中的易搜比软件、Snarfer。 微软的IE浏览器也可当作RSS阅读器使用，也含有存储的功能。 参见 消息来源 Atom (标准) XML OPML 参考资料 ^ The application&#x2F;rss+xml Media Type. Network Working Group. 2006-05-22 [2007-08-16]. 外部链接 RSS 0.90 Specification RSS 0.91 Specification RSS 1.0 Specifications RSS 2.0 Specification History of the RSS Fork (Mark Pilgrim) Building a RSS feed Tutorial with example View RSS feed RSS查看器 本文来源RSS 维基百科，自由的百科全书。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"小坏孩"},{"title":"MySQL 学习笔记 （一）","slug":"Mysql-学习笔记","date":"2020-02-28T07:31:03.000Z","updated":"2022-08-04T06:52:27.901Z","comments":true,"path":"technology/MysqlStudy.html","link":"","permalink":"https://www.sakura521.cn/technology/MysqlStudy.html","excerpt":"","text":"以下是在知乎找到的Mysql的学习笔记 1、 基本操作/* 启动 MySQL */ net start mysql /* 连接与断开服务器 */ mysql -h 地址 -p 端口 -u 用户名 -p 密码 /* 跳过权限验证登陆MySQL */ mysqld --skip-grant-tables -- 修改root密码 密码加密函数password() update mysql.user set password-password(&#39;root&#39;); /* 显示哪些线程正在运行 */ SHOW PROCESSLIST SHOW VARIABLES 2、 数据库的操作/* 数据库的操作 */ -- 查看当前数据库 slect database(); -- 显示当前时间，用户名，数据库版本 select now(),user(),version(); -- 创建数据库 create database[if not exists] 数据库名 数据库选择 数据库选项： CHARACTER SET charset_name COLLATE collation_name -- 查看已有库 show databases[ like &#39;pattern&#39;] -- 查看当前库信息 show create database 数据库名 -- 修改库的选项信息 alter database 库名 选项信息 -- 删除库 drop database[ if exists] 数据库名 同时删除该数据库相关的目录以及目录内容 3、 表的操作/* 表的操作 */ -- 创建表 create [temporary] table [if not exists] [库名.]表名(表的结构定义)[表选项] 每个字段必须有数据类型 最后一个字段后不会有逗号 temporary 临时表，会话结束时表自动消失 对于字段的定义： 字段名 数据类型 [NOT NULL | NULL][DEFAULT default_value][AUTO_INCREMENT][UNIQUE[KEY]]|[PRIMARY]KEY][COMMENT &#39;string&#39;] -- 表选项 -- 字符集 CHARSET = chareset_name 如果表没有设定，则使用数据库字符集 -- 存储引擎 ENGINE = engine_name 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式，提供的特性操作等不同 常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Examole CSV MaxDB Archive 不同的引擎在保存表的结构和数据时采用不同的方式 MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引 InnoDB表文件含义：.frm表定义，表空间数据和日志文件 SHOW ENGINES -- 显示存储引擎的状态信息 SHOW ENGINE 引擎名&#123;LOGS|STATUS&#125; -- 显示存储引擎的日志或状态信息 -- 数据文件目录 DATA DIRECTORY = ‘目录’ -- 索引文件目录 INDEX DIRECTORY = ‘目录’ -- 表注释 COMMENT = &#39;string&#39; -- 分区选项 PARTITION BY ..(详细见手册) -- 查看所有表 SHOW TABLES[LIKE &#39;pattern&#39;] SHOW TABLES FROM 表名 -- 查看表结构 SHOW CREATE TABLE 表名 （信息更详细） DESC 表名 / DESCRIBE 表名 / EXOLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &#39;PATTERN&#39;] SHOW TABLE STATUS [FROM db_name][LIKE &#39;pattern&#39;] -- 修改表 -- 修改表本身的选项 ALTER TABLE 表名 ENGINE = MYISAM; EG: ALTER TABLE 表名 ENGINE=MYISAN; -- 对表进行重命名 RENAME TABLE 原表名 TO 新表名 RENAME TABLE 原表名 TO 库名。表名 -- RENAME 可以交换两个表名 -- 修改表的字段机构 ALTER TABLE 表名 操作名 -- 操作名 ADD[COLUMN] 字段名 -- 增加字段 AFTER 字段 -- 表示增加在该字段名后面 FIRST -- 表示增加在第一个 ADD PRIMARY KEY(字段名) -- 创建主键 ADD UNIQUE [索引名]（字段名） -- 创建一个索引 ADD INDEX [索引名](字段名) -- 创建一个普通索引 ADD DROP [COLUMN] 字段名 -- 删除字段 MODIFY[COLUMN] 字段名 字段属性 -- 支持对字段属性进行修改，不能修改字段名 CHANGE[COLUMN] 原字段名 新字段名 字段属性 -- 支持对字段名修改 DROP PRIMARY KEY -- 删除主键（删除主键前删除其AUTO_INCREMENT属性） DEOP INDEX 索引名 -- 删除索引 DROP FOREIGN KEY 外键 -- 删除外键 -- 删除表 DROP TABLE [IF EXISTS] 表名 ... -- 清空数据 TRUNCATE [TABLE] 表名 -- 复制表结构 CREATE TABLE 表名 LIKE 要复制的表名 -- 复制表结构和数据 CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表 -- 检查表是否有错误 CHECK TABLE tbl_name[,tbl_name]...[option]... -- 优化表 OPTIMIZE[LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name[,tbl_name]... -- 修复表 REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [,tbl_name]...[QUICK][EXTENDED][USE_FRM] -- 分析表 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name[,tbl_name]... 未完 MySQL 学习笔记 （二） 连接https://www.sakura521.cn/2020/03/10/MysqlStudy2.html 转载原地址知乎： 老夫整理的1000行MySQL学习笔记传授有缘人","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"java","slug":"java","permalink":"https://www.sakura521.cn/tags/java/"}],"author":"小坏孩"},{"title":"Java泛型 学习笔记","slug":"Java泛型-学习笔记","date":"2020-02-27T06:26:22.000Z","updated":"2022-08-04T06:52:27.899Z","comments":true,"path":"technology/generics.html","link":"","permalink":"https://www.sakura521.cn/technology/generics.html","excerpt":"","text":"**Java泛型详解： 和Class的使用。 泛型类，泛型方法的详细使用实例** 一、 引入1、 泛型是什么ArrayList 就是泛型。那ArrayList能完成哪些想不到的功能呢？先看下面这段代码： ArrayList&lt;String&gt; strList = new ArrayList&lt;String&gt;(); ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Double&gt; doubleList = new ArrayList&lt;Double&gt;(); 这里构造了三个List分别装String、Integer和Double；这就是ArrayList的过人之处，既各种类型的变量都可以组装成对应的List。而不必针对每个类型分别实现一个构建ArrayList的类。下面看看如果没有泛型的话，我们要怎么做。 2、 没有泛型会怎样先看下面这段代码： 我们实现两个能够设置点坐标的类，分别设置Integer类型的点坐标和Float类型的点坐标. package cn.sakura.demo; public class Interger &#123; private Integer x; private Integer y; public Integer getX() &#123; return x; &#125; public void setX(Integer x) &#123; this.x = x; &#125; public Integer getY() &#123; return y; &#125; public void setY(Integer y) &#123; this.y = y; &#125; class FloatPoint &#123; private Float x; private Float y; public Float getX() &#123; return x; &#125; public void setX(Float x) &#123; this.x = x; &#125; public Float getY() &#123; return y; &#125; public void setY(Float y) &#123; this.y = y; &#125; &#125; &#125; 发现他们除了变量类型不一样，一个是Integer一个是Float以外，其他并没有是吗区别.下面将两个合成一个。因为Integer和Float都是派生自Object的，下面用代码演示： package cn.sakura.demo; public class ObjectPoint &#123; private Object x; private Object y; public Object getX() &#123; return x; &#125; public void setX(Object x) &#123; this.x = x; &#125; public Object getY() &#123; return y; &#125; public void setY(Object y) &#123; this.y = y; &#125; &#125; 既全部都用Object来代替所有的子类。 在使用的时候是这样： ObjectPoint integerPoint = new ObjectPoint(); integerPoint.setY(new Integer(100)); Integer integerX = (Integer) integerPoint.getX(); 在设置的时候，使用new Integer(100)来创建一个Integer integerPoint.setY(new Integer(100)); 然后在取值的时候，进行强制转换； Integer integerX = (Integer) integerPoint.getX(); 由于在设置的时候，是设置的Integer所以在取值的时候，轻质转换是不会出错的。 同理，FloatPoint的设置和取值也是类似的，代码如下： ObjectPoint floatPoint = new ObjectPoint(); integerPoint.setY(new Float(100,12f)); Integer floatX = (Integer) floatPoint.getX(); 如果改成下面这样也不会报错。 ObjectPoint floatPoint = new ObjectPoint(); integerPoint.setY(new Float(100,12f)); String floatX = (String) floatPoint.getX(); 强制转换时，因为编译器也不知道你传进去的是什么，而floatPoint.get()返回类型是Object，所以编译时，将Object强传成String事成立的。必然不会报错。 而在运行时，则不然，在运行时，floatPoint实例中期明明传进去的是Float类型的变量，非要把他强制转换成String类型，肯定会报类型转换的错误。 那有什么办法在编译阶段，既能合并成同一个，又能在编译时检查出来传回去类型不对呢？ 当然，这就是泛型。 下面将对泛型的写法和做法一一讲解。 二、 各种泛型定义及使用1、 泛型类定义及使用先看看泛型的类是怎么定义的； package cn.sakura.demo; public class Point&lt;T&gt; &#123; private T x; private T y; public T getX() &#123; return x; &#125; public void setX(T x) &#123; this.x = x; &#125; public T getY() &#123; return y; &#125; public void setY(T y) &#123; this.y = y; &#125; @Override public String toString() &#123; return &quot;Point&#123;&quot; + &quot;x=&quot; + x + &quot;, y=&quot; + y + &#39;&#125;&#39;; &#125; public static void main(String[] args) &#123; //IntegerPoint使用 Point&lt;Integer&gt; pointInt = new Point&lt;&gt;(); pointInt.setX(new Integer(100)); System.out.println(pointInt.getX()); //FloatPoint使用 Point&lt;Float&gt; floatPoint = new Point&lt;&gt;(); floatPoint.setX(new Float(100.12f)); System.out.println(floatPoint.getX()); &#125; &#125; 运行结果： 100 100.12 （1）、 定义泛型： PointPoint 既类名后面加一个尖括号，括号里是一个大写字母。这里写的是T，其实这个字母可以是任何大写字母，任何大写字母，意义相同。 （2）、 类中使用泛型这个T表示派生自Object类的任何类，比如String,Integer,Double等等。这里要注意的是，T一定是派生于Object类的。为了方便起见，大家可以在这里把T当成String，既String在类中怎么使用，那T在类中就可以怎么用。下面是定义变量，作为返回值，作为参数传入的定义。 //定义变量 private T x; //作为返回值 public T getX() &#123; return x; &#125; //作为参数 public void setX(T x) &#123; this.x = x; &#125; （3）、 使用泛型类用法： Point&lt;Integer&gt; pointInt = new Point&lt;&gt;(); pointInt.setX(new Integer(100)); System.out.println(pointInt.getX()); Point&lt;Float&gt; floatPoint = new Point&lt;&gt;(); floatPoint.setX(new Float(100.12f)); System.out.println(floatPoint.getX()); 首先，是构造一个实例： Point&lt;String&gt; p = new Point&lt;&gt;(); 这里与普通构造类实例的不同之点在于，普通类构造函数时这样的 Point p &#x3D;new Point(); 而泛型类的构造则需要在类名后添上，既一对尖括号，中间写上要传入的类型。 因为我们构造时，是这样的：class Point,所以在使用的时候也要在Point后加上类型来定义T代表的意义。 然后在getVar（）和setVar() 时候就没有什么特殊的了，直接调用即可。 从上面的使用时，明显可以看出泛式的作用，在构造泛式的实例的时候： Point&lt;Integer&gt; pointInt = new Point&lt;&gt;(); Point&lt;Float&gt; floatPoint = new Point&lt;&gt;(); 尖括号中，你传进去的是什么，T就代表什么类型。这就是泛型的最大作用，我们只需要考虑逻辑实现，就能拿给各种类来用。 （4）、 使用泛型实现的优势相比较开篇时使用Object的方式，又两个优点： （4.1）、 不用强制转换​ &#x2F;&#x2F;使用Object作为返回值，要强制转化成指定类型 ​ Float floatX &#x3D; (Float)floatPoint.getX(); ​ &#x2F;&#x2F;使用泛型时，不用强制转换，直接出来就是String ​ System.out.println(p.getVar()); （4.2）、 在setX()如果传入类型不对，编译时会报错​ ​ 可以看出，当我们构造时使用的是String，而在setX时，传进去Integer类型时，就会报错，而不是像Object实现方式一样，在运行时才会报强制转换错误。 2、 多泛型变量定义及字母规范（1）、 多泛型变量定义上在我们只定义了一个泛型变量T，那如果我们需要传进去多个泛型呢？ 只需要在类似下面这样就可以了； class morePoint&lt;T,U&gt;&#123; &#125; 也就是在原来的T后面用逗号隔开，多个就像下面这样： class morePoint&lt;T,U,A,C,B&gt;&#123; &#125; 举个例子，我们在Point上再加另一个字段name，也可泛型来表示，代码如下： package cn.sakura.demo; public class MorePoint&lt;T, U&gt; &#123; private T x; private T y; private U name; public T getX() &#123; return x; &#125; public void setX(T x) &#123; this.x = x; &#125; public T getY() &#123; return y; &#125; public void setY(T y) &#123; this.y = y; &#125; public U getName() &#123; return name; &#125; public void setName(U name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;morePoint&#123;&quot; + &quot;x=&quot; + x + &quot;, y=&quot; + y + &quot;, name=&quot; + name + &#39;&#125;&#39;; &#125; public static void main(String[] args) &#123; MorePoint&lt;Integer, String&gt; morePoint = new MorePoint&lt;Integer, String&gt;(); morePoint.setName(&quot;sakura&quot;); System.out.println(morePoint.getName()); &#125; &#125; （2）、 字母规范在定义泛型类时，我们已经提到用于指定泛型的变量是一个大写字母： class Point&lt;T&gt;&#123; ………… &#125; 其中任何大写字母都可以，他们的意义完全相同，但是为了提高可读性，大家默认在不同的情境下使用的字母意义如下： E Element,常用在java，Collection里，如： List,lterator,Set K,V Key,Value,代表Map的键值对 N Number,数字 T Type,类型，如String,Integer等等 3、 泛型接口定义及使用在接口上定义泛型与在类中定义泛型是一样的，代码如下： interface Info&lt;T&gt; &#123; // 在接口上定义泛型 public T getVar(); // 定义抽象方法，抽象方法的返回值就是泛型类型 public void setVar(T x); &#125; 与泛型类的定义一样，也是在接口名后加尖括号； （1）、 使用方法一：非泛型类在使用的时候，就出现了问题，先看看下面的这个使用方法： 未完 转载原网址：https://www.cnblogs.com/jpfss/p/9928747.html","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"java","slug":"java","permalink":"https://www.sakura521.cn/tags/java/"}],"author":"小坏孩"},{"title":"Java8 Lambda表达式 学习笔记","slug":"Java8-Lambda表达式-学习笔记","date":"2020-02-26T06:17:38.000Z","updated":"2022-08-04T06:52:27.899Z","comments":true,"path":"technology/lambda.html","link":"","permalink":"https://www.sakura521.cn/technology/lambda.html","excerpt":"","text":"Java 8 Lambda 表达式Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 使用 Lambda 表达式可以使代码变的更加简洁紧凑。 语法lambda 表达式的语法格式如下：(parameters) -&gt; expression 或 (parameters) -&gt;&#123; statements; &#125; 一下是lambda表达式的重要特征： 可选类型声明： 不需要声明参数类型，编译器可以统一识别参数值。 可选的参数圆括号： 一个参数无需定义圆括号，但多个参数需要定义圆括号。 可选的大括号： 如果主体包含了一个语句，就不需要大括号。 可选的返回关键字： 如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要制定明表达式返回了一个数值。 Lambda 表达式实例lambda 表达式的简单例子：//1, 不需要参数，返回值为5 () -&gt; 5 //2, 接收一个参数（数字类型），返回其两倍的值 x -&gt; 2 * x //3, 接收两个参数（数字）,并返回他们的差值 (x,y) -&gt; x - y //4, 接收两个int型整数，返回他们的和 (int x,int y) -&gt; x + y //5,接收一个 String 对象，并在控制台打印，不返回任何值（看起来像是返回void） (String s) -&gt; System.out.print(s) 在lambdaDemo.java 文件的测试：package cn.sakura.demo; public class lambdaDemo &#123; public static void main(String[] args) &#123; lambdaDemo test = new lambdaDemo(); // 类型声明 MathOperation addition = (int x, int y) -&gt; x + y; // 不同类型声明 MathOperation subraction = (x, y) -&gt; x - y; // 大括号中的返回语句 MathOperation multiplication = (int x, int y) -&gt; &#123; return x * y; &#125;; // 没有大括号及返回语句 MathOperation division = (int x, int y) -&gt; x / y; System.out.println(&quot;1+2=&quot; + test.operate(1, 2, addition)); System.out.println(&quot;1-2=&quot; + test.operate(1, 2, subraction)); System.out.println(&quot;1*2=&quot; + test.operate(1, 2, multiplication)); System.out.println(&quot;2/1=&quot; + test.operate(2, 1, division)); // 不用括号 GreetingService greetingService = message -&gt; System.out.println(&quot;https://&quot; + message); // 用括号 GreetingService greetingService2 = (message) -&gt; System.out.println(&quot;Hello&quot; + message); greetingService.sayMessage(&quot;sakura521.cn&quot;); greetingService2.sayMessage(&quot;小坏孩&quot;); &#125; interface MathOperation &#123; int operation(int a, int b); &#125; interface GreetingService &#123; void sayMessage(String message); &#125; private int operate(int a, int b, MathOperation mathOperation) &#123; return mathOperation.operation(a, b); &#125; &#125; 执行结果：1+2=3 1-2=-1 1*2=2 2/1=2 https://sakura521.cn Hello小坏孩 Process finished with exit code 0 使用 Lambda 表达式需要注意一下两点： Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的 Lambda表达式定义MathOperation接口的方法。然后我们定义了sqyMessage的执行。 Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。 变量作用域lambda 表达式只能引用标记了final的 外层局部变量，这就是说不能在lambda 内部修改定义在域外的局部变量，否则会编译错误。 代码： final static String salutation = &quot;Sakura!&quot;; public static void main(String[] args) &#123; GreetingService greetingService1 = message -&gt; System.out.println(salutation + message); greetingService1.sayMessage(&quot;小坏孩&quot;); &#125; final类 1、final类 final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。 2、final方法 如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。 使用final方法的原因有二： 第一、把方法锁定，防止任何继承类修改它的意义和实现。 第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。 输出结果：Sakura!小坏孩 我们也可以直接在 lambda 表达式中访问外层的局部变量：public static void main(String[] args) &#123; final int num = 1; Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num)); s.convert(2); &#125; 输出结果：3 易错点：lambda 表达式的局部变量可以不声明为final,但是绝对不能在后面在进行代码修改（即隐形的具有final的语义） int num = 1; Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num)); s.convert(2); num = 5; //报错信息：Local variable num defined in an enclosing scope must be final or effectively final 在Lambda 表达式当中不允许声明一个与局部变量同名的参数和局部变量。 String first = &quot;&quot;; Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length()); //编译会出错","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"java","slug":"java","permalink":"https://www.sakura521.cn/tags/java/"}],"author":"小坏孩"},{"title":"java中Map及Map.Entry详解 学习笔记","slug":"java中Map及Map-Entry详解-学习笔记","date":"2020-02-25T08:04:21.000Z","updated":"2022-08-04T06:52:27.906Z","comments":true,"path":"technology/map.html","link":"","permalink":"https://www.sakura521.cn/technology/map.html","excerpt":"","text":"Java 高级for循环 学习笔记说明：Map是java中的接口，Map.Entry是Map的一个内部接口。 Map提供了一些常用方法，如keySet()、entrySet()等方法。 keySet()方法返回值是Map中key值的集合；entrySet()的返回值也是返回一个Set集合，此集合的类型为Map.Entry。 Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry&lt;K,V&gt;。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法。 实例：import java.util.HashMap; import java.util.Iterator; import java.util.Map; public class mapEntryDemo &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;key1&quot;, &quot;value1&quot;); map.put(&quot;key2&quot;, &quot;value2&quot;); map.put(&quot;key3&quot;, &quot;value3&quot;); 第一种 通过map.keySet遍历key和value sop(&quot;通过map.keySet遍历key和value&quot;); for (String key : map.keySet()) &#123; sop(&quot;key=&quot; + key + &quot;+ &quot; + &quot;: value=&quot;+map.get(key)); &#125; 第二种 通过Map.entrySet使用iterator遍历key和value sop(&quot;通过Map.entrySet使用iterator遍历key和value&quot;); Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext())&#123; Map.Entry&lt;String,String&gt; entry = it.next(); sop(&quot;key=&quot;+entry.getKey()+&quot;+ value=&quot;+entry.getValue()); &#125; 第三种 通过Map.entrySet遍历key和value sop(&quot;通过Map.entrySet遍历key和value&quot;); for (Map.Entry&lt;String,String&gt; entry:map.entrySet())&#123; sop(entry.getKey()+&quot;:&quot;+entry.getValue()); &#125; 第四种 通过Map.values()遍历所有的value，但不遍历key sop(&quot;通过Map.values()遍历所有的value，但不遍历key&quot;); for (String v : map.values()) &#123; sop(&quot;value:&quot; + v); &#125; 补充 sop private static void sop(Object s) &#123; System.out.println(s); &#125; &#125; 转载原地址：java中Map及Map.Entry详解","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"java","slug":"java","permalink":"https://www.sakura521.cn/tags/java/"}],"author":"小坏孩"},{"title":"Java 高级for循环 学习笔记","slug":"Java-高级for循环-学习笔记","date":"2020-02-25T07:05:34.000Z","updated":"2022-08-04T06:52:27.898Z","comments":true,"path":"technology/javafor.html","link":"","permalink":"https://www.sakura521.cn/technology/javafor.html","excerpt":"","text":"高级for循环格式：for(数据类型 变量名：被遍历的集合(Collection)或者数组){} 对集合进行遍历。 只能获取元素，但是不能对集合进行操作。 注意：迭代器除了遍历，还可以进行remove集合中元素的动作。 如果使用Listlerator,还可以在遍历的过程中对集合进行增删改查的动作。 区别：传统for循环和高级for循环的区别 高级for有一个局限性。必须有被遍历的目标。 建议：在遍历数组的时候，还是希望使用传统for，因为传统for可以定义脚标。 实例：import java.util.ArrayList; import java.util.HashMap; import java.util.Map; import java.util.Set; public class ForEachDemo &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;(); al.add(&quot;add1&quot;); al.add(&quot;add2&quot;); al.add(&quot;add3&quot;); for (String s : al) &#123; System.out.println(s); &#125; System.out.println(al); HashMap&lt;Integer, String&gt; hm = new HashMap&lt;Integer, String&gt;(); hm.put(1, &quot;hello1&quot;); hm.put(3, &quot;hello3&quot;); hm.put(2, &quot;hello2&quot;); hm.put(4, &quot;hello4&quot;); Set&lt;Integer&gt; set = hm.keySet(); for (Integer i : set) &#123; sop(i + &quot;..&quot; + hm.get(i)); &#125; Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set1 = hm.entrySet(); for (Map.Entry&lt;Integer, String&gt; me : set1) &#123; Integer key = me.getKey(); String value = me.getValue(); sop(key + &quot;: &quot; + value); &#125; &#125; private static void sop(Object s) &#123; System.out.println(s); &#125; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"java","slug":"java","permalink":"https://www.sakura521.cn/tags/java/"}],"author":"小坏孩"},{"title":"live 2d 看板娘 官方文档","slug":"live-2d-看板娘","date":"2020-02-21T06:17:16.000Z","updated":"2022-08-04T06:52:27.907Z","comments":true,"path":"technology/live2D.html","link":"","permalink":"https://www.sakura521.cn/technology/live2D.html","excerpt":"","text":"Live2D Widget 特性 Feature在网页中添加 Live2D 看板娘。兼容 PJAX，支持无刷新加载。Add Live2D widget to web page. Compatible with PJAX. 警告：本项目使用了大量 ES6 语法，且依赖于 WebGL。不支持 IE 11 等老旧浏览器。WARNING: This project does not support legacy browsers such as IE 11. 示例 Demo在米米的博客的左下角可查看效果。 这个仓库中也提供了两个 Demo，即 demo1.html ，展现基础效果 demo2.html ，仿 NPM 的登陆界面 依赖 Dependencies本插件需要 Font Awesome 4.7.0 支持，请确保相关样式表已在页面中加载，例如在 &lt;head&gt; 中加入：Font Awesome 4.7.0 is required for this plugin. You can add this to &lt;head&gt;: &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;&gt; 否则无法正常显示。（如果网页中已经加载了 Font Awesome，就不要重复加载了） 使用 Usage将这一行代码加入 &lt;head&gt; 或 &lt;body&gt;，即可展现出效果： &lt;script src=&quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js&quot;&gt;&lt;/script&gt; 如果网站启用了 PJAX，由于看板娘不必每页刷新，因此要注意将相关脚本放到 PJAX 刷新区域之外。 换句话说，如果你是小白，或者只需要最基础的功能，就只用把这一行代码，连同前面加载 Font Awesome 的一行代码，一起放到 html 的 &lt;head&gt; 中即可。对于用各种模版引擎（例如 Nunjucks，Jinja 或者 PHP）生成的页面，也要自行修改，方法类似，只是可能略为麻烦。以 Hexo 为例，需要在主题相关的 ejs 或 njk 模版中正确配置路径，才可以加载。 但是！我们强烈推荐自己进行配置，否则很多功能是不完整的，并且可能产生问题！如果你有兴趣自己折腾的话，请看下面的详细说明。 Using CDN要自定义有关内容，可以把这个仓库 Fork 一份，然后进行修改。这时，使用方法对应地变为 &lt;script src=&quot;https://cdn.jsdelivr.net/gh/username/live2d-widget@latest/autoload.js&quot;&gt;&lt;/script&gt; 将 username 替换为你的 GitHub 用户名即可。 Self-host你也可以直接把这些文件放到服务器上，而不是通过 CDN 加载。 如果你能够通过 ssh 访问你的主机，请把整个仓库克隆到服务器上。执行： cd /path/to/your/webroot # Clone this repository git clone https://github.com/stevenjoezhang/live2d-widget.git 如果你的主机无法用 ssh 连接（例如一般的虚拟主机），请选择 Download ZIP，然后通过 ftp 等方式上传到主机上，再解压到网站的目录下。 如果你是通过 Hexo 等工具部署的静态博客，请在本地开命令行进入博客目录，例如 source 下与 _posts 同级的目录，然后再执行前述的 git clone 命令。重新部署博客时，相关文件就会自动上传到对应的路径下。 这样，整个项目就可以通过你的服务器 IP 或者域名从公网访问了。不妨试试能否正常地通过浏览器打开 autoload.js 和 live2d.min.js 等文件，并确认这些文件的内容是正确的，没有出现乱码。一切正常的话，接下来修改一些配置就行了。（需要通过服务器上的文本编辑器修改；你也可以先在本地完成这一步骤，再上传到服务器上）修改 autoload.js 中的常量 live2d_path 为 live2d-widget 这一文件夹在公网上的路径。比如说，如果你能够通过 https://www.example.com/path/to/live2d-widget/live2d.min.js 访问到 live2d.min.js，那么就把 live2d_path 的值修改为 https://www.example.com/path/to/live2d-widget/ 路径末尾的 / 一定要加上。具体可以参考 autoload.js 内的注释。完成后，在你要添加看板娘的界面加入 &lt;script src=&quot;https://www.example.com/path/to/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; 就可以加载了。 目录结构 Files waifu-tips.json 中包含了触发条件（selector，选择器）和触发时显示的文字（text）； waifu.css 是看板娘的样式表。 源文件是对 Hexo 的 NexT 主题有效的，为了适用于你自己的网页，可能需要自行修改，或增加新内容。警告：作者不对包括但不限于 waifu-tips.json 和 waifu-tips.js 文件中的内容负责，请自行确保它们是合适的。 如果有任何疑问，欢迎提 Issue。如果有任何修改建议，欢迎提 Pull Request。 鸣谢 Credits感谢 BrowserStack 容许我们在真实的浏览器中测试此项目。Thanks to BrowserStack for allowing us to test this project in real browsers. 代码自这篇博文魔改而来：https://www.fghrsh.net/post/123.html 点击看板娘的纸飞机按钮时，会出现一个彩蛋，这来自于 WebsiteAsteroids。 更多 More更多内容可以参考：https://imjad.cn/archives/lab/add-dynamic-poster-girl-with-live2d-to-your-blog-02https://github.com/xiazeyu/live2d-widget.jshttps://github.com/summerscar/live2dDemo 还可以自行搭建后端 API，并增加模型（需要修改的内容比较多，此处不再赘述）：https://github.com/fghrsh/live2d_apihttps://github.com/xiazeyu/live2d-widget-modelshttps://github.com/xiaoski/live2d_models_collection 除此之外，还有桌面版本：https://github.com/amorist/platelethttps://github.com/akiroz/Live2D-Widget 许可证 LicenseReleased under the GNU General Public License v3http://www.gnu.org/licenses/gpl-3.0.html 本仓库中涉及的所有 Live2D 模型、图片、动作数据等版权均属于其原作者，仅供研究学习，不得用于商业用途。 Live2D 官方网站：https://www.live2d.com/en/https://live2d.github.io Live2D Cubism Core は Live2D Proprietary Software License で提供しています。https://www.live2d.com/eula/live2d-proprietary-software-license-agreement_en.htmlLive2D Cubism Components は Live2D Open Software License で提供しています。http://www.live2d.com/eula/live2d-open-software-license-agreement_en.html The terms and conditions do prohibit modification, but obfuscating in live2d.min.js would not be considered illegal modification. https://community.live2d.com/discussion/140/webgl-developer-licence-and-javascript-question 更新 Update2018年10月31日，由 fghrsh 提供的原 API 停用，请更新至新地址。参考文章：https://www.fghrsh.net/post/170.html 2020年1月1日起，本项目不再依赖于 jQuery。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"小坏孩"},{"title":"Hexo 常用命令","slug":"Hexo-常用命令","date":"2020-02-21T02:22:16.000Z","updated":"2022-08-04T06:52:27.897Z","comments":true,"path":"technology/hexo.html","link":"","permalink":"https://www.sakura521.cn/technology/hexo.html","excerpt":"","text":"常用命令npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客 命令简写hexo n “我的博客” &#x3D;&#x3D; hexo new “我的博客” #新建文章hexo g &#x3D;&#x3D; hexo generate #生成hexo s &#x3D;&#x3D; hexo server #启动服务预览hexo d &#x3D;&#x3D; hexo deploy #部署 hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"小坏孩"},{"title":"测试，我的第一篇文章","slug":"测试，我的第一篇文章","date":"2020-02-20T12:15:44.000Z","updated":"2022-08-04T06:52:27.910Z","comments":true,"path":"technology/Firstpost.html","link":"","permalink":"https://www.sakura521.cn/technology/Firstpost.html","excerpt":"","text":"这是我的第一篇文章进行测试测试","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.sakura521.cn/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://www.sakura521.cn/tags/%E6%82%A6%E8%AF%BB/"}],"author":"小坏孩"},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura - 副本","date":"2018-12-12T14:16:01.000Z","updated":"2022-08-04T06:52:27.896Z","comments":true,"path":"technology/Sakura2.html","link":"","permalink":"https://www.sakura521.cn/technology/Sakura2.html","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: &#123; path: /, fa: fa-fort-awesome faa-shake &#125; 归档: &#123; path: /archives, fa: fa-archive faa-shake, submenus: &#123; 技术: &#123;path: /categories/技术/, fa: fa-code &#125;, 生活: &#123;path: /categories/生活/, fa: fa-file-text-o &#125;, 资源: &#123;path: /categories/资源/, fa: fa-cloud-download &#125;, 随想: &#123;path: /categories/随想/, fa: fa-commenting-o &#125;, 转载: &#123;path: /categories/转载/, fa: fa-book &#125; &#125; &#125; 清单: &#123; path: javascript:;, fa: fa-list-ul faa-vertical, submenus: &#123; 书单: &#123;path: /tags/悦读/, fa: fa-th-list faa-bounce &#125;, 番组: &#123;path: /bangumi/, fa: fa-film faa-vertical &#125;, 歌单: &#123;path: /music/, fa: fa-headphones &#125;, 图集: &#123;path: /tags/图集/, fa: fa-photo &#125; &#125; &#125; 留言板: &#123; path: /comment/, fa: fa-pencil-square-o faa-tada &#125; 友人帐: &#123; path: /links/, fa: fa-link faa-shake &#125; 赞赏: &#123; path: /donate/, fa: fa-heart faa-pulse &#125; 关于: &#123; path: /, fa: fa-leaf faa-wrench , submenus: &#123; 我？: &#123;path: /about/, fa: fa-meetup&#125;, 主题: &#123;path: /theme-sakura/, fa: iconfont icon-sakura &#125;, Lab: &#123;path: /lab/, fa: fa-cogs &#125;, &#125; &#125; 客户端: &#123; path: /client/, fa: fa-android faa-vertical &#125; RSS: &#123; path: /atom.xml, fa: fa-rss faa-pulse &#125; # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - &#123;url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png&#125; - &#123;url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg&#125; - &#123;url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg&#125; # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: &#123;url: http://github.com/honjun, img: /img/social/github.png&#125; sina: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png&#125; wangyiyun: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png&#125; zhihu: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png&#125; email: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg&#125; wechat: &#123;url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png&#125; # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: &#123;url: http://github.com/honjun, fa: fa-github, color: 333&#125; weibo: &#123;url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39&#125; qq: &#123;url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe&#125; # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： &#123;% bili video_id [page] %&#125; 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： &#123;% fb_img src [caption] %&#125; 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.sakura521.cn/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://www.sakura521.cn/tags/%E6%82%A6%E8%AF%BB/"}],"author":"hojun"},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2022-08-04T06:52:27.896Z","comments":true,"path":"technology/sakura.html","link":"","permalink":"https://www.sakura521.cn/technology/sakura.html","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: &#123; path: /, fa: fa-fort-awesome faa-shake &#125; 归档: &#123; path: /archives, fa: fa-archive faa-shake, submenus: &#123; 技术: &#123;path: /categories/技术/, fa: fa-code &#125;, 生活: &#123;path: /categories/生活/, fa: fa-file-text-o &#125;, 资源: &#123;path: /categories/资源/, fa: fa-cloud-download &#125;, 随想: &#123;path: /categories/随想/, fa: fa-commenting-o &#125;, 转载: &#123;path: /categories/转载/, fa: fa-book &#125; &#125; &#125; 清单: &#123; path: javascript:;, fa: fa-list-ul faa-vertical, submenus: &#123; 书单: &#123;path: /tags/悦读/, fa: fa-th-list faa-bounce &#125;, 番组: &#123;path: /bangumi/, fa: fa-film faa-vertical &#125;, 歌单: &#123;path: /music/, fa: fa-headphones &#125;, 图集: &#123;path: /tags/图集/, fa: fa-photo &#125; &#125; &#125; 留言板: &#123; path: /comment/, fa: fa-pencil-square-o faa-tada &#125; 友人帐: &#123; path: /links/, fa: fa-link faa-shake &#125; 赞赏: &#123; path: /donate/, fa: fa-heart faa-pulse &#125; 关于: &#123; path: /, fa: fa-leaf faa-wrench , submenus: &#123; 我？: &#123;path: /about/, fa: fa-meetup&#125;, 主题: &#123;path: /theme-sakura/, fa: iconfont icon-sakura &#125;, Lab: &#123;path: /lab/, fa: fa-cogs &#125;, &#125; &#125; 客户端: &#123; path: /client/, fa: fa-android faa-vertical &#125; RSS: &#123; path: /atom.xml, fa: fa-rss faa-pulse &#125; # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - &#123;url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png&#125; - &#123;url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg&#125; - &#123;url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg&#125; # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: &#123;url: http://github.com/honjun, img: /img/social/github.png&#125; sina: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png&#125; wangyiyun: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png&#125; zhihu: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png&#125; email: &#123;url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg&#125; wechat: &#123;url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png&#125; # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: &#123;url: http://github.com/honjun, fa: fa-github, color: 333&#125; weibo: &#123;url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39&#125; qq: &#123;url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe&#125; # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： &#123;% bili video_id [page] %&#125; 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： &#123;% fb_img src [caption] %&#125; 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.sakura521.cn/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://www.sakura521.cn/tags/%E6%82%A6%E8%AF%BB/"}],"author":"hojun"}],"categories":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/categories/%E6%8A%80%E6%9C%AF/"},{"name":"干货","slug":"干货","permalink":"https://www.sakura521.cn/categories/%E5%B9%B2%E8%B4%A7/"},{"name":"娱乐","slug":"娱乐","permalink":"https://www.sakura521.cn/categories/%E5%A8%B1%E4%B9%90/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://www.sakura521.cn/tags/%E6%8A%80%E6%9C%AF/"},{"name":"java","slug":"java","permalink":"https://www.sakura521.cn/tags/java/"},{"name":"web","slug":"web","permalink":"https://www.sakura521.cn/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://www.sakura521.cn/tags/%E6%82%A6%E8%AF%BB/"},{"name":"干货","slug":"干货","permalink":"https://www.sakura521.cn/tags/%E5%B9%B2%E8%B4%A7/"},{"name":"娱乐","slug":"娱乐","permalink":"https://www.sakura521.cn/tags/%E5%A8%B1%E4%B9%90/"},{"name":"B站","slug":"B站","permalink":"https://www.sakura521.cn/tags/B%E7%AB%99/"}]}